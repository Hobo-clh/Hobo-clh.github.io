<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>synchronized必知必会</title>
      <link href="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p>synchronized作为java中的一个关键字，它有以下用途</p><ul><li><p>修饰在静态方法上</p><p>静态方法是可以通过类名直接调用，所以实际上就是对调用方法的类加锁，俗称类锁</p></li><li><p>修饰在成员方法上</p><p>成员方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁</p></li><li><p>修饰在代码块上</p><p>根据传入的是类对象或类实例判断加锁方式</p></li></ul><blockquote><p>类锁：为什么可以对类上锁，因为每个java类在jvm中都会有一个真正的class对象，这个class对象就是一个普通的对象，所以类锁和对象所是一致的</p></blockquote><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>对象头&gt;</p><p>对象被创建后，随即会在在堆中为其分配内存空间，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p><p>其中对象头又分成了三块区域</p><ul><li><p>Mark Word</p></li><li><p>指向类的指针</p></li><li><p>数组长度（只有数组对象才有）</p></li></ul><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png"  alt="image-20200811003015388"></p><h3 id="Monitor机制（重量级锁）"><a href="#Monitor机制（重量级锁）" class="headerlink" title="Monitor机制（重量级锁）"></a>Monitor机制（重量级锁）</h3><p>Monitor 被翻译为监视器或管程，也叫做监视器锁（重量级锁） 每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 就被设置为指向 Monitor 对象的指针</p><ul><li><p>刚开始 Monitor 中 Owner 为 null </p></li><li><p>当有一个线程1执行到synchronized(obj)时就会将Monitor的持有者设置成线程1，而Monitor中只能有一 个 Owner</p></li><li><p>当其他的线程也来执行synchronized(obj)时，就会进入EntryList被阻塞，处于BLOCKED状态</p></li><li><p>当线程1执行完同步代码块的内容后，会释放锁然后唤醒EntryList中等待的线程来竞争锁，非公平状态</p></li></ul><blockquote><p>注意：</p><ul><li><p>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </p></li><li><p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></li></ul><p>公平锁概念：</p><ul><li><p>公平锁：获取不到锁的时候，会自动加入队列，等待线程释放后，队列的第一个线程获取锁</p></li><li><p>非公平锁：获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争</p></li></ul><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)</p></blockquote><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/syn3.png"  alt="image-20200811001330019"></p><h2 id="JDK1-6之后对synchronized的优化"><a href="#JDK1-6之后对synchronized的优化" class="headerlink" title="JDK1.6之后对synchronized的优化"></a>JDK1.6之后对synchronized的优化</h2><p>锁的状态总共有四种，<strong>无锁状态</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p><ul><li><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cyn1.png"  alt="image-20200811002827603"></p></li><li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</p><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/syn5.png"  alt="image-20200811002855462"></p></li><li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/syn6.png"  alt="image-20200811003144728"></p></li><li><p>如果 cas 失败，有两种情况 </p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="/" class="lazyload" data-src="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/syn7.png"  alt="image-20200811003218604"></p><h3 id="CAS自旋锁（乐观锁）"><a href="#CAS自旋锁（乐观锁）" class="headerlink" title="CAS自旋锁（乐观锁）"></a>CAS自旋锁（乐观锁）</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。</p><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><h4 id="撤销-调用hashcode方法"><a href="#撤销-调用hashcode方法" class="headerlink" title="撤销-调用hashcode方法"></a>撤销-调用hashcode方法</h4><p>因为对象在调用hashcode方法后会将其hashcode值存入之MarkWord中，会占用31位替换掉线程id，导致偏向锁被撤销</p><h4 id="撤销-调用wait-notify方法"><a href="#撤销-调用wait-notify方法" class="headerlink" title="撤销-调用wait/notify方法"></a>撤销-调用wait/notify方法</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程</p><h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p><h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>无锁–偏向锁–轻量锁–重量锁</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之索引快速入门</title>
      <link href="/2020/08/09/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2020/08/09/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>在数据之外，MySQL还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用着数据，这样就可以在这些数据结构上实现一些高级查找算法。这种数据结构就是索引。<br>简而言之：索引是一种用于<strong>排序和快速查找</strong>的数据结构。<br>索引本身也很大，所以以索引文件的形式存储在磁盘中</p><h3 id="索引优势"><a href="#索引优势" class="headerlink" title="索引优势"></a>索引优势</h3><ol><li>大大加快查找的速度，提高数据的检索效率，减少了数据的IO成本</li><li>加快排序数据的速度，较少了CPU的消耗</li></ol><h3 id="索引劣势"><a href="#索引劣势" class="headerlink" title="索引劣势"></a>索引劣势</h3><ol><li>索引会占用了空间</li><li>索引虽然会增加排序和查找的速度，但是会降低更新、删除、新增数据时的速度，因为MySQL此时不仅仅的要更改表，同时也要对调整表变化后索引的信息</li></ol><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ol><li><p>唯一索引：索引列的值必须唯一，但允许有空值</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># table为表名，indexName索引名，colum列名</span></span><br><span class="line">CREATE UNIQUE INDEX indexName ON table(column);</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ALTER table ADD UNIQUE INDEX indexName ON (column);</span><br></pre></td></tr></table></figure></li><li><p>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">CREATE INDEX indexName ON table(column);</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ALTER table ADD INDEX indexName ON (column);</span><br></pre></td></tr></table></figure></li><li><p>复合索引：一个索引包含多个列</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON table(column1,column2,...);</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ALTER table ADD INDEX indexName ON (column1,column2,...);</span><br></pre></td></tr></table></figure></li><li><p>全文索引：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX indexName ON table(column);</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ALTER TABLE table ADD FULLTEXT indexName ON (column);</span><br></pre></td></tr></table></figure></li></ol><h3 id="什么情况下需要用索引"><a href="#什么情况下需要用索引" class="headerlink" title="什么情况下需要用索引"></a>什么情况下需要用索引</h3><ol><li>主键会自动创建唯一索引</li><li>频繁作为查询条件的字段需要创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或分组字段<h3 id="什么情况下不需要用索引"><a href="#什么情况下不需要用索引" class="headerlink" title="什么情况下不需要用索引"></a>什么情况下不需要用索引</h3></li><li>表的数据太少</li><li>经常增删改的字段不需要创建索引<br> 索引提高了查询速度，同时会降低更新表的速度，如对表进行 insert , update , delete 因为表更新时，<br>MySQL 不仅仅要保存数据，还要保存索引文件。</li><li>数据重复，且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。<br>如果某个数据列包含多个重复的内容，为它建立索引就没有太大的实际效果。</li></ol><h2 id="索引失效原因总结"><a href="#索引失效原因总结" class="headerlink" title="索引失效原因总结"></a>索引失效原因总结</h2><ol><li>最佳左前缀法则：</li></ol><blockquote><pre><code>如果索引了多列，需要准守最左前缀法则，指的是查询从索引的最左前列开始并且 不跳过索引中的列。</code></pre></blockquote><ol start="2"><li>不在索引列上左任何操作 （计算、函数、（自动 or 手动）类型转换）， 会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少 select *</li><li>mysql 在适应不等于 （!= 或者 &lt;&gt;）的时候无法使用索引会导致全表扫描</li><li>is null, is not null 也无法使用索引</li><li>ike 以通配符开头 （’%abc …’）mysql 索引失效会变成全表扫描的操作</li><li>字符串不加单引号索引失效</li><li>少用 or, 用它来连接时会索引失效</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS虚拟机配置桥接网卡</title>
      <link href="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/"/>
      <url>/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我使用的是VM VirtualBox安装的CentOS7虚拟机，安装方式直接问度娘，这里不过多阐述啦</p><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><p><img src="/" class="lazyload" data-src="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/xnj1.png"  alt="image-20200805085832706"></p><p><img src="/" class="lazyload" data-src="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/xnj3.png"  alt="image-20200805090042391"></p><p><img src="/" class="lazyload" data-src="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/xnj2.png"  alt="image-20200805090414436"></p><h3 id="进入修改网络配置文件"><a href="#进入修改网络配置文件" class="headerlink" title="进入修改网络配置文件"></a>进入修改网络配置文件</h3><p><code>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加或者修改如下配置，其他不用变，自己Windows下ip地址可以使用命令 ipconfig</span><br><span class="line"></span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line"><span class="comment"># 例如我的网络是 192.168.104.1 则可以修改为192.168.104.*</span></span><br><span class="line">IPADDR=192.168.104.248</span><br><span class="line"><span class="comment"># 跟本地一致</span></span><br><span class="line">NETMASK=255.255.255.0 </span><br><span class="line"><span class="comment"># 跟本地网关一致</span></span><br><span class="line">GATEWAY=192.168.104.1</span><br></pre></td></tr></table></figure><h4 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h4><p><code>systemctl restart network</code></p><h3 id="ping下Windows主机"><a href="#ping下Windows主机" class="headerlink" title="ping下Windows主机"></a>ping下Windows主机</h3><p><img src="/" class="lazyload" data-src="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/xnj4.png"  alt="image-20200805091613040"></p><h3 id="Windows主机ping虚拟机"><a href="#Windows主机ping虚拟机" class="headerlink" title="Windows主机ping虚拟机"></a>Windows主机ping虚拟机</h3><p><img src="/" class="lazyload" data-src="/2020/08/05/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1/xnj5.png"  alt="image-20200805091708107"></p><p><strong>结束~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> 记录 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-Easy:删除排序数组中的重复项</title>
      <link href="/2020/08/01/LeetCode-Easy-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2020/08/01/LeetCode-Easy-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-Easy-26：删除排序数组中的重复项"><a href="#LeetCode-Easy-26：删除排序数组中的重复项" class="headerlink" title="LeetCode-Easy 26：删除排序数组中的重复项"></a>LeetCode-Easy 26：删除排序数组中的重复项</h2><h3 id="原题"><a href="#原题" class="headerlink" title="原题:"></a>原题:</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(<span class="number">1</span>) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class="line"></span><br><span class="line">请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有了思路还是挺简单的</span><br><span class="line">思路如下</span><br><span class="line"></span><br><span class="line">由题目得，该数组为一个排序数组，所以我假设一个数组 nums &#x3D; [0,0,1,1,1,2,2,3,3,4,4]</span><br><span class="line"></span><br><span class="line">使用双指针：changIndex指针指向需要改变的位置  index指针用来遍历数组</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    &#x2F;&#x2F;首先进行校验，如果num.length &lt; 1;直接返回num.length</span><br><span class="line">        if(nums.length &lt;&#x3D; 1) &#123;</span><br><span class="line">            return nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;记录数组的不重复数长度</span><br><span class="line">        int flag&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;遍历数组的指针</span><br><span class="line">        int index &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F;记录当前位置需要改变的指针</span><br><span class="line">        int changeIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;遍历数组</span><br><span class="line">        while(index &lt; nums.length ) &#123;</span><br><span class="line">            if(nums[index] !&#x3D; nums[index-1]) &#123;</span><br><span class="line">                &#x2F;&#x2F;index 值 与 index-1 进行比较，如果不相同，则需要将值放至changeIndx处</span><br><span class="line">                nums[changeIndex] &#x3D; nums[index-1];</span><br><span class="line">                changeIndex++;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后跳出来把最后一个值放在changIndex处</span><br><span class="line">        nums[changeIndex] &#x3D; nums[index-1];</span><br><span class="line">        return ++flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行用时：1 ms, 在所有 Java 提交中击败了98.22%的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode-Easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Redis</title>
      <link href="/2020/07/22/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/"/>
      <url>/2020/07/22/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h2><h3 id="下载Redis压缩包防止Linux服务器"><a href="#下载Redis压缩包防止Linux服务器" class="headerlink" title="下载Redis压缩包防止Linux服务器"></a>下载Redis压缩包防止Linux服务器</h3><p><a href="https://redis.io/" target="_blank" rel="noopener">官网</a>下载redis的安装包 </p><p>我下载的是目前最新的 redis-6.0.5.tar.gz</p><p>我把压缩包放至在 /usr/local/redis 下</p><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.0.5.tar.gz</span><br><span class="line"><span class="comment"># 解压好后进入redis-6.0.5</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.5</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>如果编译出现了错误 可能是gcc版本没有安装或者太低的原因，使用以下命令解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看gcc版本</span></span><br><span class="line">gcc -v  </span><br><span class="line"><span class="comment"># 升级到9.1版本</span></span><br><span class="line">yum -y install centos-release-scl  </span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"><span class="comment">#注意：scl命令启用只是临时的，推出xshell或者重启就会恢复到原来的gcc版本。</span></span><br><span class="line"><span class="comment">#如果要长期生效的话，执行如下：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/rh/devtoolset-9/enable"</span> &gt;&gt;/etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成后重写编译 如果还出现问题可以删除redis-6.0.5后，再进行编译安装</span></span><br></pre></td></tr></table></figure><h3 id="修改redis-conf配置文件"><a href="#修改redis-conf配置文件" class="headerlink" title="修改redis.conf配置文件"></a>修改redis.conf配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在redis-6.0.5文件夹下有一个redis.conf配置文件</span></span><br><span class="line"><span class="comment"># 编辑</span></span><br><span class="line">vi redis.conf</span><br><span class="line"><span class="comment"># 修改为以下</span></span><br><span class="line">将<span class="built_in">bind</span> 127.0.0.1 修改为  <span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">daemonize no 修改为daemonize yes</span><br></pre></td></tr></table></figure><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用redis.conf配置文件开启redis服务</span></span><br><span class="line">redis-server redis.conf</span><br><span class="line"><span class="comment"># 进入redis客户端</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment"># 之后就进入了redis客户端</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="本地连接Redis"><a href="#本地连接Redis" class="headerlink" title="本地连接Redis"></a>本地连接Redis</h3><p>在本地使用Redis Desktop Manager连接服务器Redis</p><p>输入ip后出现连接不上的情况，原因可能是防火墙没有关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="comment"># 暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 永久关闭防火墙  （暂时还没试过）</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/jxldjsn/p/10794171.html" target="_blank" rel="noopener">https://www.cnblogs.com/jxldjsn/p/10794171.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现分布式session（理论）</title>
      <link href="/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
      <url>/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8Fsession/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式session-理论解决思路"><a href="#分布式session-理论解决思路" class="headerlink" title="分布式session-理论解决思路"></a>分布式session-理论解决思路</h2><h3 id="为什么需要分布式session？"><a href="#为什么需要分布式session？" class="headerlink" title="为什么需要分布式session？"></a>为什么需要分布式session？</h3><p>首先聊聊session和cookie，session对象存储在服务器端节点内存中，cookie存储在客户端浏览器中。一般是客户端请求服务器，服务器端生成session对象，将session对象存储在jvm内存中，并且在响应头中放入sessionId响应给客户端，客户端收到响应后，将sessionid存储在本地。当浏览器第二次请求时会将本地cookie中存储的seesionId通过请求头的方式传递给服务器，这样服务器和客户端就能保持会话信息啦！如下图</p><p>生成cookie</p><p><img src="/" class="lazyload" data-src="/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8Fsession/response.png"  alt="image-20200719122631443"></p><p>有cookie后，每次向服务器发送请求都会带上cookie</p><p><img src="/" class="lazyload" data-src="/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8Fsession/request.png"  alt="image-20200719122841887"></p><p>简而言之，</p><p>当有一台服务器时，用户登录 成功后，服务器生成session将用户信息存放其中，并且以sessionid的形式返回给客户端存放在cookie中（sessionid和服务器生成的session对应）， 以后客服端每次访问时，都会在cookie中携带这个sessionid，当服务端收到请求时，如果请求中包含了这个sessionid，则会把session检索出来，此时服务器getSession的就是客服端对应的session，这样就形成了一个会话。</p><p>那么为什么会出现分布式session问题呢，为了提高服务器端的负载能力，后台一般将服务器节点做集群，通过ngnix通过轮询的方式转发到目标服务器。打个比方，当浏览器首次访问A服务器生成session对象，然后在访问生成的session对象，如果正好被ngnix转发到了A服务器，那么没问题可以获取到session对象，如果不巧请求被转发到B服务器，由于之前生成的session对象在A服务器，B服务器根本没有生成session对象，很自然访问不到session对象。</p><h3 id="理论解决思路"><a href="#理论解决思路" class="headerlink" title="理论解决思路"></a>理论解决思路</h3><p>通过上文后，相比大家都对session和cookie有了一定的了解。</p><p>上述的问题在于 session只能存在一台服务器上，无法实现共享。</p><p>如果不将session信息存储在jvm内存上，而是放在Redis中，是不是就可以达到共享了呢？</p><p>我们模仿session的机制，使用token代替sessionid，</p><p>当用户发起登录请求成功后，随机生成一个token，使用token为key将用户信息存放在Redis中，然后生成一个cookie存放token。当用户发起请求时都会携带这个token过来，我们获取这个token，从redis中查找用户信息。</p><p>这样实现了一个分布式session（共享session）</p><p>token就是sessionid，redis相当于session，使用token从redis中获取用户信息，相当于通过sessionid获取到session中的用户信息。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/95687710" target="_blank" rel="noopener">分布式session共享解决方案(知乎)-一叶知秋</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2020/06/15/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/15/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>堆排序</strong>：<br>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong>：<br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p><strong>堆排序的基本思想是</strong>：<br>1、将待排序序列构造成一个大顶堆（升序大顶堆，降序小顶堆）<br>2、此时，整个序列的最大值就是堆顶的根结点<br>3、将其与末尾元素进行交换，此时末尾就为最大值<br>4、如何将剩余n-1个元素重写构造成一个堆，这样就会得到n个元素的次小值。<br>如此反复执行，便能得到一个有序序列</p><p>时间复杂度：O(nlogn)<br>稳定度：不稳定</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//找到第一个非叶子结点 （arr.lentgh / 2 - 1 的索引处就是第一个非叶子结点）</span></span><br><span class="line"><span class="comment">//排成一个大顶堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">adjustHeap(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将顶部和最后一个元素交换位置</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- )&#123;</span><br><span class="line">temp =  arr[i];</span><br><span class="line">arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = temp;</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调整为以i为父节点的大顶堆（重点难点）</span></span><br><span class="line"><span class="comment">    * 将一个数组（二叉树），调整成一个大顶堆</span></span><br><span class="line"><span class="comment">    * 举例：int[] arr = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到&#123;9, 4, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment">    * 如果再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到&#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9, 6, 8, 5, 4&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr    arr 待调整的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i      i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length 表示多少个元素继续调整，length 是在追歼的减少</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义一个临时变量，用于交换</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">//找到结点i的左子结点，并且每次循环找到k的下一个左子节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//判断左子节点是否小于右子结点，（前提是k+1 必须小于length）</span></span><br><span class="line"><span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="comment">//如果小于，则k++，即k指向右子结点</span></span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前节点和k结点比较大小</span></span><br><span class="line"><span class="keyword">if</span>(arr[k] &gt; temp) &#123;</span><br><span class="line"><span class="comment">//交换位置</span></span><br><span class="line">arr[i] = arr[k];</span><br><span class="line"><span class="comment">//使i指向k，即继续循环 因为交换位置可能会破坏顺序</span></span><br><span class="line">i = k; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳出循环后，我们已经将以 i 为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a><br><a href="https://www.cnblogs.com/-citywall123/p/11788764.html" target="_blank" rel="noopener">满二叉树、完全二叉树、平衡二叉树、最优二叉树</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该方法采用经典的分治策略（分治法将问题分成一些<strong>小的问题然后递归求解</strong>，而治的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）</p><p>通俗一点就是<br>将数组分解到最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><p>时间复杂度：O(nlogn)<br>稳定度：稳定</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分解操作</span></span><br><span class="line"><span class="comment">    *      先分解</span></span><br><span class="line"><span class="comment">    *      再合并</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left  无序序列的左边起始索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 无序序列的右边起始索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort3</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           <span class="comment">//左边分解</span></span><br><span class="line">           mergeSort3(arr,left,mid,temp);</span><br><span class="line">           <span class="comment">//右边分解</span></span><br><span class="line">           mergeSort3(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">           <span class="comment">//合并</span></span><br><span class="line">           merge3(arr,left,mid,right,temp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 合并</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> l = left;<span class="comment">//初始化l，左边有序序列的初始索引</span></span><br><span class="line">       <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">//初始化j，右边有序序列的初始索引</span></span><br><span class="line">       <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、比较左右两组序列，将小的值填充到temp</span></span><br><span class="line">       <span class="keyword">while</span>(l &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[l] &lt; arr[j])&#123;</span><br><span class="line">               temp[t] = arr[l];</span><br><span class="line">               l++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               temp[t] = arr[j];</span><br><span class="line">               j++;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           t++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2、把剩下的没填充的数组填充</span></span><br><span class="line">       <span class="keyword">while</span>(l &lt;= mid)&#123;</span><br><span class="line">           temp[t] = arr[l];</span><br><span class="line">           l++;</span><br><span class="line">           t++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">           temp[t] = arr[j];</span><br><span class="line">           j++;</span><br><span class="line">           t++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3、copy数组temp到原数组</span></span><br><span class="line">       t = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right;i++ )&#123;</span><br><span class="line">           arr[i] = temp[t];</span><br><span class="line">           t++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序介绍"><a href="#快速排序介绍" class="headerlink" title="快速排序介绍"></a>快速排序介绍</h2><p> 快速排序（Quicksort）是对冒泡排序的一种改进。</p><blockquote><p>基本思想是：<br>      通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，<br>      然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序</p></blockquote><p>时间复杂度： O(nlogn)<br>稳定度：不稳定</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 思路：</span></span><br><span class="line"><span class="comment">    * 会先把数组中的一个数当作基准数（一般会拿数组中最左边的数）</span></span><br><span class="line"><span class="comment">    * 然后从两边进行检索，使用 j 先从右边检索比基准数小的数。</span></span><br><span class="line"><span class="comment">    * 再使用 i 从左边检索比基准数大的数。如果检索到了，就停下来，然后交换这两个元素。</span></span><br><span class="line"><span class="comment">    * 然后再继续检索，直到 i 和 j 相遇</span></span><br><span class="line"><span class="comment">    * 如果 i 和 j 相遇就停下来，基准数和相遇位置的数进行交换，交换基准数表示第一轮排序结束</span></span><br><span class="line"><span class="comment">    * 此时这个基准数已经归位，左边都比它小，右边都比他大</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 使用递归，分左右进行第二轮（，）</span></span><br><span class="line"><span class="comment">    * 排基准数的左边 quickSort(int[] arr, int left, l - 1)</span></span><br><span class="line"><span class="comment">    * 排基准数的右边 quickSort(int[] arr, int r, right)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr   要排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left  左起点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 右终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义变量保存基准数</span></span><br><span class="line">       <span class="keyword">int</span> base = arr[left];</span><br><span class="line">       <span class="comment">//定义变量r，指向最右边</span></span><br><span class="line">       <span class="keyword">int</span> r = right;</span><br><span class="line">       <span class="comment">//定义变量l，指向最左边</span></span><br><span class="line">       <span class="keyword">int</span> l = left;</span><br><span class="line">       <span class="comment">//临时变量，用作交换</span></span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="comment">//当i和j不相遇的时候，在循环中进行检索</span></span><br><span class="line">       <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">           <span class="comment">//由r从右向左检索，如果检索到比base小的数就停下来</span></span><br><span class="line">           <span class="keyword">while</span> (arr[r] &gt;= base &amp;&amp; l &lt; r) &#123;</span><br><span class="line">               <span class="comment">//j从右往左移动</span></span><br><span class="line">               r--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//l从右向左检索，如果检索到比base大的数就停下来</span></span><br><span class="line">           <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; l &lt; r) &#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//r和i都停下了,交换位置</span></span><br><span class="line">           temp = arr[l];</span><br><span class="line">           arr[l] = arr[r];</span><br><span class="line">           arr[r] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//到这里说明l和r相遇了</span></span><br><span class="line">       <span class="comment">//如果l和r相遇了 就交换基准数和相遇位置的元素</span></span><br><span class="line">       arr[left] = arr[l];</span><br><span class="line">       arr[l] = base;</span><br><span class="line">       <span class="comment">//基准数在这里就归为了，左边的数字都比它小，右边的都比它大</span></span><br><span class="line">       <span class="comment">//排基准数的左边</span></span><br><span class="line">       quickSort2(arr, left, l - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//排基准数的右边</span></span><br><span class="line">       quickSort2(arr, r + <span class="number">1</span>, right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2020/06/10/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/10/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单插入排序可能会出现的问题"><a href="#简单插入排序可能会出现的问题" class="headerlink" title="简单插入排序可能会出现的问题"></a>简单插入排序可能会出现的问题</h2><p><img src="/" class="lazyload" data-src="/2020/06/10/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png"  alt="在这里插入图片描述"><br>显而易见，当大多数的数已经排序好，只有小的数在最后面的时候，插入排序的效率是非常低的。</p><h2 id="希尔排序介绍"><a href="#希尔排序介绍" class="headerlink" title="希尔排序介绍"></a>希尔排序介绍</h2><p>   希尔排序是希尔于1959年题出的一种排序算法，希尔排序也是一种插入排序，他是简单插入<br>     希尔排序是把序列按一定间隔分组，对每组使用直接插入排序；随着间隔减小，一直到1，使得整个序列有序</p><p>时间复杂度：O(nlogn)<br>稳定度：不稳定</p><blockquote><p>思路：<br>1）将数组进行分组，<br>第一次分组 组数为 gap = arr.length/2,<br>接下来的分组 组数为 gap/2，循环直到组数为1<br>2）获得分组,只需遍历一半的元素，就可以获得再其中小组的成员<br>for(int i = gap;i&lt;arr.length;i++) {<br>判断小组中成员的大小，小放前，大放后</p></blockquote><h3 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 交换法 速度慢(不推荐)</span></span><br><span class="line"><span class="comment">    * 里面实际上就是一个 分了组的冒泡排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="comment">//希尔排序的第一轮排序</span></span><br><span class="line">       <span class="comment">//因为第一轮排序，是将10个数据分成了5组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="comment">//缺点：里面实际上就是一个冒泡排序</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="comment">//遍历各组中所有的元素（共gap组，每组有arr.length/gap个元素），步长gap</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                   <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                   <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                       temp = arr[j];</span><br><span class="line">                       arr[j] = arr[j + gap];</span><br><span class="line">                       arr[j + gap] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="缩小增量法"><a href="#缩小增量法" class="headerlink" title="缩小增量法"></a>缩小增量法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 速度比交换法快，推荐</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     *      1）先进行分组</span></span><br><span class="line"><span class="comment">     *      2）然后循环每个分组，在分组中再进行插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//每组进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;arr.length - gap;j+=gap)&#123;</span><br><span class="line">                    <span class="comment">//要进行插入的元素</span></span><br><span class="line">                    <span class="keyword">int</span> insert = arr[j + gap];</span><br><span class="line">                    <span class="comment">//要插入的位置</span></span><br><span class="line">                    <span class="keyword">int</span> insetIndex = j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (insetIndex&gt;=<span class="number">0</span> &amp;&amp; insert &lt; arr[insetIndex]) &#123;</span><br><span class="line">                        <span class="comment">//将大数往后移动一位</span></span><br><span class="line">                        arr[insetIndex + gap] = arr[insetIndex];</span><br><span class="line">                        <span class="comment">//指针前移</span></span><br><span class="line">                        insetIndex -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//找到的插入的位置</span></span><br><span class="line">                    arr[insetIndex+gap] = insert;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println("第"+(++count)+"轮:"+Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>什么是插入排序？<br>通俗理解就是，把n个待排序的元素看成一个有序表和无序表，有序表最开始为1，无序表为n-1，<br>每进行一轮排序，从无序表中取出第一个元素，将其与有序表元素进行比较，将其放入一个合适的位置。<br>最后形成的一个完整有序表。</p></blockquote><p>时间复杂度：O(n^2)<br>稳定度：稳定</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> value;<span class="comment">//从无序表中取出来要进行插入的值</span></span><br><span class="line">       <span class="keyword">int</span> index;<span class="comment">//被插入的索引位置</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="comment">//打印</span></span><br><span class="line">           System.out.println(<span class="string">"第"</span> + (i - <span class="number">1</span>) + <span class="string">"轮"</span> + Arrays.toString(arr));</span><br><span class="line">           <span class="comment">//取出插入值</span></span><br><span class="line">           value = arr[i];</span><br><span class="line">           <span class="comment">//index设置为value的初始位置</span></span><br><span class="line">           index = i;</span><br><span class="line">           <span class="comment">//index必须 &gt;= 1 防止溢出，与index的前一个元素进行比较</span></span><br><span class="line">           <span class="keyword">while</span> (index &gt;= <span class="number">1</span> &amp;&amp; value &lt; arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="comment">//元素后移一位</span></span><br><span class="line">               arr[index] = arr[index - <span class="number">1</span>];</span><br><span class="line">               index--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//insertIndex变化则进行插入</span></span><br><span class="line">           <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">               arr[index] = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort2Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//随便测试</span></span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">98</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">323</span>,<span class="number">125</span>,<span class="number">743</span>&#125;;</span><br><span class="line">       insertSort2(arr);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong><br><img src="/" class="lazyload" data-src="/2020/06/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B5%8B%E8%AF%95.png"  alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归-迷宫问题、八皇后问题</title>
      <link href="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="递归简单介绍"><a href="#递归简单介绍" class="headerlink" title="递归简单介绍"></a>递归简单介绍</h2><p>递归就是方法自己调用自己，每次调用时传入不同的遍历，<strong>递归有助于编程者解决复杂的问题</strong>，同时可以让代码变得简洁</p><h2 id="递归能解决什么样的问题"><a href="#递归能解决什么样的问题" class="headerlink" title="递归能解决什么样的问题"></a>递归能解决什么样的问题</h2><p><img src="/" class="lazyload" data-src="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98.png"  alt="在这里插入图片描述"></p><h2 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h2><p><img src="/" class="lazyload" data-src="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99.png"  alt="在这里插入图片描述"></p><h2 id="迷宫回溯问题"><a href="#迷宫回溯问题" class="headerlink" title="迷宫回溯问题"></a>迷宫回溯问题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用递归回溯来给小球找路<br>1、如果小球能到map[6][5] 位置，则说明通路找到了<br>2、约定：当map[i][j]为0 表示该点没有走过<br>当为1表示墙 2表示通过可以走 3表示改位置已经走过 但是走不通<br>3、在走迷宫时，需要确定一个策略（方法） 下-&gt;右-&gt;下-&gt;左，如果该点走不通再回溯</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> map   表示地图,地图中 1表示墙 2表示通过可以走 3表示改位置已经走过</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> i     出发点横坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> j     出发点纵坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tr    目标点横坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tc    目标点纵坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>      如果找到通路，返回true，否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> tr, <span class="keyword">int</span> tc)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//通过已经找到</span></span><br><span class="line">      <span class="keyword">if</span> (map[tr][tc] == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果当前这个点还没走过</span></span><br><span class="line">          <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//策略：下-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">              <span class="comment">//假定该点是可以走通</span></span><br><span class="line">              map[i][j] = <span class="number">2</span>;</span><br><span class="line">              <span class="comment">//向下走</span></span><br><span class="line">              <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j, tr, tc)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>, tr, tc)) &#123;</span><br><span class="line">                  <span class="comment">//向右走</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j, tr, tc)) &#123;</span><br><span class="line">                  <span class="comment">//向上走</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>, tr, tc)) &#123;</span><br><span class="line">                  <span class="comment">//向左走</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">                  map[i][j] = <span class="number">3</span>;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果map[i][j] != 0 ,可能是1，2，3</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] initMap()&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">       <span class="comment">//使用1代表墙</span></span><br><span class="line">       <span class="comment">//第一行和最后一行设为墙</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">           map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">           map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//第一列和最后设为墙</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">           map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">           map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置挡板</span></span><br><span class="line">       map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">       map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先创建一个 8行 7列 的二维数组 模拟迷宫</span></span><br><span class="line">       <span class="comment">//地图</span></span><br><span class="line">       <span class="keyword">int</span>[][] map = initMap();</span><br><span class="line">       <span class="comment">//遍历二维数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">               System.out.print(anInt + <span class="string">"\t"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//使用递归回溯 给小球找路</span></span><br><span class="line">       setWay(map, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">       <span class="comment">//输出新的地图，小球走过并表示过的递归</span></span><br><span class="line">       System.out.println(<span class="string">"小球走过并表示过的递归"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">               System.out.print(anInt + <span class="string">"\t"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E8%BF%B7%E5%AE%AB%E7%BB%93%E6%9E%9C.png"  alt="在这里插入图片描述"></p><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>游戏地址 <a href="http://www.4399.com/flash/42643.htm#search3" target="_blank" rel="noopener">八皇后小游戏</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="/" class="lazyload" data-src="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E7%9A%87%E5%90%8E%E6%80%9D%E8%B7%AF.png"  alt="在这里插入图片描述"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个max表示共有多少个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组array,保存皇后放置位置的结果，比如arr = &#123;0,4,7,5,2,6,1,3&#125;</span></span><br><span class="line"><span class="comment">     * 下标index+1就是皇后的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录解法</span></span><br><span class="line">    <span class="keyword">int</span> judgeCount = <span class="number">0</span>;<span class="comment">//记录冲突次数</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//放置第n个皇后</span></span><br><span class="line">   <span class="comment">//特别注意：check 是每一次递归式，进入到 check 中都有一个for循环，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == MAX) &#123;</span><br><span class="line">            <span class="comment">//n == 8时，8个皇后已经放好</span></span><br><span class="line">            count++;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAX;i++)&#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n，放在该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当前第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123;</span><br><span class="line">                <span class="comment">//不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个皇后，即开始递归</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i；即将第n个皇后，放置在本行的后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后，就去检测该皇后和前面已经摆放的皇后是否冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        judgeCount+=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">           <span class="comment">//说明：</span></span><br><span class="line">           <span class="comment">// 1、判断这个皇后是否和前面n-1个皇后在同一列</span></span><br><span class="line">           <span class="comment">// 2、Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个黄河是否和第i个皇后在同一斜线上</span></span><br><span class="line">           <span class="comment">// 3、不用判断是否在同一列，因为下标就代表了列</span></span><br><span class="line">           <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打印放好了的皇后序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//测试一把，8皇后是否正确</span></span><br><span class="line">        Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count = queue8.getCount();</span><br><span class="line">        System.out.printf(<span class="string">"一共有%d种解法\n"</span>,count);</span><br><span class="line">        System.out.printf(<span class="string">"一共有%d次冲突"</span>,queue8.judgeCount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="/2020/06/09/%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E7%9A%87%E5%90%8E%E7%BB%93%E6%9E%9C.png"  alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈（数组、单链表实现栈）</title>
      <link href="/2020/06/09/%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%EF%BC%89/"/>
      <url>/2020/06/09/%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表实现栈"><a href="#单链表实现栈" class="headerlink" title="单链表实现栈"></a>单链表实现栈</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用链表模拟栈<br>         思路：<br>         入栈：当要插入数据时，直接将其放在头节点之后<br>         newNode.next = head.next; head.next = newNode;<br>         出栈：删除返回头节点的下一个节点，<br>         StackNode data = head.next;<br>         head.next = head.next.next;<br>         return data.value;<br>         遍历：list(),从头节点开始遍历</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StackNode head;<span class="comment">//头节点 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> StackNode(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈已满，无法放入！！！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode newNode = <span class="keyword">new</span> StackNode(value);</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">            newNode.next = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"大兄弟，栈是空的！！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode node = head.next;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"大兄弟，栈是空的！！！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode temp = head.next;</span><br><span class="line">        System.out.println(<span class="string">"遍历所有值"</span>);</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack:"</span>+temp.value);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StackNode</span> </span>&#123;</span><br><span class="line">        StackNode next;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StackNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StackNode</span><span class="params">(StackNode next, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a>数组实现栈</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>定义一个maxSize，表示栈的大小<br>使用一个top指针，来表示栈顶元素；<br>入栈时，top++，arr[top] = 新元素；<br>出栈时，，arr[top]就是要出栈的元素，然后top–；</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用数组实现栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈 数据旧放在改数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;<span class="comment">//表示栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"maxSize的值不合法！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从顶开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈是空的，大兄弟！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"stack[%d] = %d\n"</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表以及约瑟夫问题</title>
      <link href="/2020/06/09/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/06/09/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Java编写环形单向链表"><a href="#Java编写环形单向链表" class="headerlink" title="Java编写环形单向链表"></a>Java编写环形单向链表</h2><p>单向环形链表，跟单链表的唯一区别就是尾结点会指向头节点，形成一个循环(循环)链表。<br>使用 Java 实现单向环形链表的添加和遍历方法。</p><p>思路：<br>先创建第一个节点, 让 first的next指针指向该节点，并形成环形<br>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.<br>遍历环形链表</p><p>先让一个辅助指针(变量) curBoy，指向first节点<br>然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束<br>根据用户的输入，生成一个小孩出圈的顺序</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//添加小孩节点，构件成一个环形的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//使用for循环创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"小孩编号："</span> + curBoy.getNo());</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125; <span class="keyword">while</span> (curBoy != first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个Boy，表示一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no, Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set/get省略了...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Boy&#123;"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p><img src="/" class="lazyload" data-src="/2020/06/09/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98.png"  alt="在这里插入图片描述"><br>思路：用一个辅助指针，指向最后一个结点，当最后一个结点等于首个节点时，说明只剩下最后一个人了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户的输入，计算小孩除权的顺序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums     表示最初由多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先对数据进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">        System.out.println(<span class="string">"参数输入有误，请重新输入"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boy helper = first.getNext();</span><br><span class="line">    <span class="comment">//使辅助指针helper指向最后一个小孩</span></span><br><span class="line">    <span class="keyword">while</span> (helper.getNext() != first) &#123;</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小孩报数前，先让 first 和 helper移动 startNo - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当小孩报数使，先让 first 和 helper 指针同时的移动 countNum  - 1 次，然后出圈</span></span><br><span class="line">    <span class="comment">//这里是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当 helper == first 使 表示只有一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (helper != first) &#123;</span><br><span class="line">        <span class="comment">//让 first 和 helper 指针同时的移动 countNum -1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"小孩"</span>+first.getNo()+<span class="string">"出圈"</span>);</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper.setNext(first);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"最后留着圈中的小孩"</span>+first.getNo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表以及常见算法题</title>
      <link href="/2020/06/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/06/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表简单介绍"><a href="#单链表简单介绍" class="headerlink" title="单链表简单介绍"></a>单链表简单介绍</h2><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><h2 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h2><p>实现单链表的添加、更新、删除、遍历、获取链表长度等方法<br>首先定义一个节点类HereNode，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname, HeroNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     * 思路，不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1、找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2、将最后这个节点的 next 指向新节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出循环时，指向链表最后</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.no==heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">"这个排名："</span>+heroNode.no+<span class="string">"已经存在了"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">     * 根据id大小顺序添加，如果id重复，则无法添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addById</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heroNode.no == temp.next.no) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"已存在该排名：%d\n"</span>, heroNode.no);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heroNode.no &lt; temp.next.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的temp就说我们想插入的位置的</span></span><br><span class="line">        heroNode.next = temp.next;</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了该节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到排名为"</span> + newHeroNode.no + <span class="string">"的英雄"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有排名为"</span>+ no +<span class="string">"的英雄！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的面试题"><a href="#单链表的面试题" class="headerlink" title="单链表的面试题"></a>单链表的面试题</h2><h3 id="查找单链表中倒数第k个节点-【新浪面试题】"><a href="#查找单链表中倒数第k个节点-【新浪面试题】" class="headerlink" title="查找单链表中倒数第k个节点 【新浪面试题】"></a>查找单链表中倒数第k个节点 【新浪面试题】</h3><p>思路：</p><ol><li>单链表的长度-k+1，就是链表正序的位置，例如：链表长度为10，k为9，则正序位置为2，也就是第二个结点</li><li>前提是 长度 - k &gt;=0, 且 k不能小于等于0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">selectByK</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//getLength()为获取链表的长度，即有效元素个数</span></span><br><span class="line">       <span class="keyword">if</span>(k &lt;= <span class="number">0</span> &amp;&amp; k &gt; getLength())&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"K值："</span>+k+<span class="string">"，不合法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">int</span> index = getLength - k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的反转-【腾讯面试题】"><a href="#单链表的反转-【腾讯面试题】" class="headerlink" title="单链表的反转 【腾讯面试题】"></a>单链表的反转 【腾讯面试题】</h3><p>思路：<br>定义一个新的链表，将旧链表（要反转的链表）的元素遍历，依次插入头结点的后面，并连接好头节点后面的原结点。最后新链表就是反转后的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单链表的反转 【腾讯面试题】 有点难度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">reverse</span><span class="params">(SingleLinkedList oldList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (oldList.getLength() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (oldList.getLength() == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> oldList;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义一个新单向链表</span></span><br><span class="line">       SingleLinkedList newList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">       <span class="comment">//临时变量1，表示 旧链表的首个有效元素</span></span><br><span class="line">       HeroNode temp = oldList.head.next;</span><br><span class="line">       <span class="comment">//临时变量2</span></span><br><span class="line">       HeroNode temp2 = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//遍历 旧链表</span></span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//将旧链表的元素取出来</span></span><br><span class="line">           temp2 = temp;</span><br><span class="line">           <span class="comment">//旧链表后移</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">           temp2.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将旧链表的元素依次放入新链表的头部的下一节点</span></span><br><span class="line">           temp2.next = newList.head.next;</span><br><span class="line">           newList.head.next = temp2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="逆序打印单向链表-【百度面试题】"><a href="#逆序打印单向链表-【百度面试题】" class="headerlink" title="逆序打印单向链表 【百度面试题】"></a>逆序打印单向链表 【百度面试题】</h3><p>思路1：使用栈这种数据结构进行存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 逆序打印单向链表 【百度面试题】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HeroNode temp = head.next;</span><br><span class="line">       <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//链表为空不打印</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">           stack.push(temp);</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.out.println(stack.pop());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路2：使用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reversePrint2</span><span class="params">(HeroNode startNode)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (startNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (startNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           reversePrint2(startNode.next);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (startNode != head) &#123;</span><br><span class="line">           System.out.println(startNode);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（使用Java数组模拟队列）</title>
      <link href="/2020/06/08/%E9%98%9F%E5%88%97%EF%BC%88%E4%BD%BF%E7%94%A8Java%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%EF%BC%89/"/>
      <url>/2020/06/08/%E9%98%9F%E5%88%97%EF%BC%88%E4%BD%BF%E7%94%A8Java%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>将之前的知识整理一下</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作<br>简而言之，就是遵循先入先出原则。</p><h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>队列是一个<strong>有序列表</strong>，可以用数组或是链表来实现<br>特点：遵循<strong>先入先出</strong>的原则。<strong>先存入队列的数据，要先取出，后存入的要后取出。</strong></p><h3 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h3><p>队列本身是有序列表，使用数组的结构来存储队列的数据<br>因为队列的输出、输入是分别从头部尾部来处理，因此需要两个变量 front 和 rear 分别记录队列头部尾部的下标，front 会随着数据输出而改变，而 rear 则是随着数据的输入而改变</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//底层数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line"><span class="keyword">this</span>.front == -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.rear == -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == manSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//先判断队列满了没</span></span><br><span class="line"><span class="keyword">if</span>(isFull())&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已满"</span>);</span><br><span class="line">&#125;</span><br><span class="line">rear++;<span class="comment">//尾指针+1</span></span><br><span class="line">arr[rear] = n;<span class="comment">//赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d] = %d\n"</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><p>此队列有以下问题</p><ol><li>数组不能得到充分利用，使用了一次就不能复用</li><li>将这个数组使用算法，改进成一个环形数组 取模 %</li></ol><h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ol><li>front变量的含义做一个调整 front指向队列的第一个元素，也就是说arr[front] 就说队列的第一个元素，front的初始值=0</li><li>rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值=0</li><li>当队列满时，条件是 （rear+1）% maxSize = front【满】<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示数组的最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * front变量的含义做一个调整 front指向队列的第一个元素，</span></span><br><span class="line"><span class="comment">     *      也就是说arr[front] 就说队列的第一个元素，front的初始值=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，</span></span><br><span class="line"><span class="comment">     *      因为希望空出一个空间作为约定，rear的初始值=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放数据，模拟队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrManSize)</span></span>&#123;</span><br><span class="line">        maxSize = arrManSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否满</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+<span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据到队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已满，不能加了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让rear后移</span></span><br><span class="line">        arr[rear] = n ;</span><br><span class="line">        rear = (rear+<span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析出 front 是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1、先把 front 对应的值保存在一个临时变量</span></span><br><span class="line">        <span class="comment">//2、将 front 后移</span></span><br><span class="line">        <span class="comment">//3、将临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示队列的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front;i&lt;front+size();i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d] = %d\n"</span>,i%maxSize,arr[i%maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出当前队列有效数据的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//rear = 1</span></span><br><span class="line">        <span class="comment">//front = 2</span></span><br><span class="line">        <span class="comment">//maxsize = 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示队列的头数据，注意不是取出数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么重写equals方法后一定要重写hashCode方法？</title>
      <link href="/2020/06/05/%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/05/%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>在java的Object类中，equals()比较的是两个对象的引用地址，如果是基本数据类型比较的就是值。</p><h2 id="为什么说重写equals方法后一定要重写hashcode方法？"><a href="#为什么说重写equals方法后一定要重写hashcode方法？" class="headerlink" title="为什么说重写equals方法后一定要重写hashcode方法？"></a>为什么说重写equals方法后一定要重写hashcode方法？</h2><p>我的理解就是 ，当在使用HashSet（这里只拿HashSet展开）的去重机制时，他会将存入HashSet的元素进行去重处理，那么是如何进行去重的呢？HashSet底层用的是Hash表的一种数据结构（一个元素为链表的数组）<br>他会首先判断要添加的元素的hash值，同过hash值的计算算出该元素在其底层数组中的索引，查看索引处是否存在元素，如果存在则使用equals方法，如果为true则不添加，如果为false则添加在次索引处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整理一下差不多如下</span><br><span class="line">执行顺序：</span><br><span class="line">    首先比较哈希值是否相同</span><br><span class="line">        相同：继续执行equals()方法</span><br><span class="line">               返回true：元素重复了，不添加</span><br><span class="line">               返回false：直接把元素添加到集合</span><br><span class="line">        不同：就直接把元素添加到集合</span><br></pre></td></tr></table></figure><p>此时如果我定义一个Student类,只重写equals方法如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">if</span> (age != student.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(student.name) : student.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>);</span><br><span class="line">System.out.println(student1.equals(student2));<span class="comment">//true</span></span><br><span class="line">System.out.println(student1.hashCode());<span class="comment">//1163157884</span></span><br><span class="line">System.out.println(student2.hashCode());<span class="comment">//1956725890</span></span><br></pre></td></tr></table></figure><p>发现其equals相同，而hashcode是不相同的，因为他调用的是父类Object的hashCode方法,而equals相同而hashcode值不同，这样在HashSet集合中是不允许的，因为他先判断其hashCode值，发现不相同就直接插入在集合中了，达不到去重的效果，<strong>所以重写了equals方法一定要重写hashCode方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="有关hashCode的规定："><a href="#有关hashCode的规定：" class="headerlink" title="有关hashCode的规定："></a>有关hashCode的规定：</h2><ul><li>两个对象相等，其hashcode值一定相同;</li><li>两个对象不相等，其hashcode值有可能相同;</li><li>hashcode相同的两个对象，不一定相等;</li><li>hashcode不相同的两个对象，一定不相等;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于三次握手四次挥手的理解</title>
      <link href="/2020/06/05/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/06/05/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP简述"><a href="#TCP简述" class="headerlink" title="TCP简述"></a>TCP简述</h2><p>TCP协议是面向连接的、可靠的、基于字节流的传输层通信协议。其中最出名的就是三次握手和四次挥手</p><h2 id="什么是三次握手"><a href="#什么是三次握手" class="headerlink" title="什么是三次握手"></a>什么是三次握手</h2><p>三次握手的建立。连接必须先由一方主动发起，另一方被动接受的<br><img src="/" class="lazyload" data-src="/2020/06/05/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E6%8F%A1%E6%89%8B.jpg"  alt="三次握手"><br>简单来说就是 </p><ol><li>首先客户端给服务端发送一个请求，请求连接</li></ol><ol start="2"><li><p>服务端接收到客户端发来的请求,回一个，“我已收到你发来的请求，我同意发起连接” </p></li><li><p>客户端接收到服务端的请求,回一个,“好的，我已经收到你的同意的信号了”</p></li></ol><p>然后就开始传输数据了</p><h3 id="为什么是三次握手而不是两次或四次握手？"><a href="#为什么是三次握手而不是两次或四次握手？" class="headerlink" title="为什么是三次握手而不是两次或四次握手？"></a>为什么是三次握手而不是两次或四次握手？</h3><p>因为TCP是可靠传输协议，两次握手的话，可能会出先死锁的情况。<br>比如，当C端要向S端发送请求，第一次请求连接，S端收到后，发送同意请求，回复“我同意连接”，因为是两次握手，所以S端已经打开了连接并且可以向C端发送数据，。此时，如果S端发送的同意请求丢失了，C端并不知道S端收到了我的建立连接的请求，所以会忽略S端发来的数据，S端发送的数据没有得到C端的响应，就会一直发送。这样就造成了死锁的情况。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手"></a>什么是四次挥手</h2><p>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。<br><img src="/" class="lazyload" data-src="/2020/06/05/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg"  alt="四次挥手"></p><p>简单描述下</p><ol><li><p>客户端向服务端发送关闭连接请求，“请求关闭连接”</p></li><li><p>服务端收到请求，并回“我收到了，给我时间准备一下”</p></li><li><p>当服务端准备好了，又回客户端“我准备好了关闭连接了”</p></li><li><p>客户端接收服务端到这一次的请求后，回复“那我们关闭连接吧” 等待2MSL,关闭，服务端收到后也关闭连接</p></li></ol><h3 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h3><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p> 当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p><p>如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；<br>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Java注解</title>
      <link href="/2020/05/28/%E5%AD%A6%E4%B9%A0Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/05/28/%E5%AD%A6%E4%B9%A0Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>百度是这样说的：从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息 。</p><h2 id="java中注解作用分类"><a href="#java中注解作用分类" class="headerlink" title="java中注解作用分类"></a>java中注解作用分类</h2><ol><li>编写文档：通过代码里表示的注解生成文档【生成doc文档】</li><li>代码分析：通过代码里表示的注解对代码进行分析【使用反射】</li><li>编译检查：通过代码里表示的注解让编译器能够实现基本的编译检查【Override】</li></ol><h2 id="JDK中预定义的一些注解"><a href="#JDK中预定义的一些注解" class="headerlink" title="JDK中预定义的一些注解"></a>JDK中预定义的一些注解</h2><ul><li><code>@Override</code>：检测呗改注解标注的方法是否是继承自父类（接口）的</li><li><code>@Deprecated</code>：</li><li><code>@SuppressWarnings</code>：压制警告,消除所有警告</li></ul><h2 id="元注解：用于描述注解的注解"><a href="#元注解：用于描述注解的注解" class="headerlink" title="元注解：用于描述注解的注解"></a>元注解：用于描述注解的注解</h2><ul><li><code>@Target</code>：描述注解能够作用的位置</li></ul><blockquote><p>ElementType取值（枚举）：</p><ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></blockquote><ul><li><code>@Retention</code>：描述注解被保留的阶段<br>  <code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会被保留到class字节码文件中，并被JVM读取到（常用）</li><li><code>@Documented</code>：描述注解是否被抽取到api文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">元注解()</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>本质</strong>：注解本质上就是一个接口，该接口默认继承Annotation接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">interface</span> <span class="title">MaAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span></span><br></pre></td></tr></table></figure><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性：接口中的抽象方法</p><ol><li>属性的返回值类型</li><li>基本数据类型<blockquote><ul><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></blockquote></li></ol><ol start="3"><li>定义的属性，在使用时需要给属性赋值<pre><code>- 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值- 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可</code></pre></li></ol><h3 id="在程序使用（解析）注解"><a href="#在程序使用（解析）注解" class="headerlink" title="在程序使用（解析）注解"></a>在程序使用（解析）注解</h3><p>在程序使用（解析）注解:获取注解中定义的属性值</p><ol><li>获取注解定义的位置的对象（Class,Method,Field）</li><li>获取指定的注解</li><li>调用注解中的抽象方法获取配置的属性值</li></ol><h2 id="自定义注解小案例"><a href="#自定义注解小案例" class="headerlink" title="自定义注解小案例"></a>自定义注解小案例</h2><p>需求：使用注解的方式，检测以下方法是否存在bug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 + 0 ="</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 - 0 ="</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 * 0 ="</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 / 0 ="</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义注解类Check</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//会被编译到字节码文件中，运行时一直生效</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)<span class="comment">//可以使用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Calculate类的方法上添加<code>@Check</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"1 + 0 ="</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Check</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"1 - 0 ="</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Check</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"1 * 0 ="</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Check</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"1 / 0 ="</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>编写解析类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCheck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试框架</span></span><br><span class="line"><span class="comment">     * 当主方法执行后，会自动执行被检测的所有方法（加了Check注解的方法），</span></span><br><span class="line"><span class="comment">     * 判断方法是否有异常，记录到文件中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建计算器对象</span></span><br><span class="line">        Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="comment">//2、获取字节码文件对象</span></span><br><span class="line">        Class&lt;? extends Calculator&gt; cls = c.getClass();</span><br><span class="line">        <span class="comment">//3、获取所有方法</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line">        <span class="comment">//出现异常的次数</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bug.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//4、判断方法上是否有Check注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Check<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//5、有，执行</span></span><br><span class="line">                    method.invoke(c);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//6、捕获异常</span></span><br><span class="line">                    number++;</span><br><span class="line">                    bw.write(method.getName() + <span class="string">"方法出异常了"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常的名称："</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常的原因："</span> + e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"----------------------------------"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">"本次测试一共出现"</span> + number + <span class="string">"次异常"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/" class="lazyload" data-src="/2020/05/28/%E5%AD%A6%E4%B9%A0Java%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"  alt="在这里插入图片描述"><br>生成了bug.tex文件记录异常信息<br><img src="/" class="lazyload" data-src="/2020/05/28/%E5%AD%A6%E4%B9%A0Java%E6%B3%A8%E8%A7%A3/bug%E6%96%87%E4%BB%B6%E5%9B%BE.png"  alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用<ul><li>编译器</li><li>给解析程序用</li></ul></li><li>注解不是程序的一部分，可以理解为注解就是一个标签</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot参数校验</title>
      <link href="/2020/05/18/Validated%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2020/05/18/Validated%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot参数校验"><a href="#Spring-Boot参数校验" class="headerlink" title="Spring Boot参数校验"></a>Spring Boot参数校验</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在web开发中，前端的参数校验可以提高用户的体验，后端的参数校验为了数据的安全。<br>在之前的开发中参数校验一般如下图</p><p><img src="/" class="lazyload" data-src="/2020/05/18/Validated%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/images.png"  alt><br>没有任何问题，只有有些不简洁不优雅<br>使用 hibernate-validator 来进行参数校验</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><p>版本自由选择</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常用的校验注解"><a href="#常用的校验注解" class="headerlink" title="常用的校验注解"></a>常用的校验注解</h4><ul><li>@AssertFalse 所注解的元素必须是Boolean类型，且值为false</li><li>@AssertTrue 所注解的元素必须是Boolean类型，且值为true</li><li>@DecimalMax 所注解的元素必须是数字，且值小于等于给定的值</li><li>@DecimalMin 所注解的元素必须是数字，且值大于等于给定的值</li><li>@Digits 所注解的元素必须是数字，且值必须是指定的位数</li><li>@Future 所注解的元素必须是将来某个日期</li><li>@Max 所注解的元素必须是数字，且值小于等于给定的值</li><li>@Min 所注解的元素必须是数字，且值小于等于给定的值</li><li>@Range 所注解的元素需在指定范围区间内</li><li>@NotNull 所注解的元素值不能为null</li><li>@NotBlank 所注解的元素值有内容</li><li>@Null 所注解的元素值为null</li><li>@Past 所注解的元素必须是某个过去的日期</li><li>@PastOrPresent 所注解的元素必须是过去某个或现在日期</li><li>@Pattern 所注解的元素必须满足给定的正则表达式</li><li>@Size 所注解的元素必须是String、集合或数组，且长度大小需保证在给定范围之内</li><li>@Email 所注解的元素需满足Email格式</li></ul><blockquote><p> @NotNull  验证对象是否不为null, 无法查检长度为0的字符串： 不能为null，但可以为空字符串<br> @NotBlank   检查约束 (字符串) 是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.： 只能作用在String上，不能为null，而且调用trim()后，长度必须大于0<br> @NotEmpty   检查(集合)约束元素是否为NULL或者是EMPTY.  ： 不能为null，并且长度必须大于0<br>              @NotEmpty修饰的String类、Collection、Map、数组，是不能为null或者长度为0的(String Collection Map的isEmpty()方法)</p></blockquote><h4 id="参数校验的两种场景"><a href="#参数校验的两种场景" class="headerlink" title="参数校验的两种场景"></a>参数校验的两种场景</h4><h5 id="单个参数校验"><a href="#单个参数校验" class="headerlink" title="单个参数校验"></a>单个参数校验</h5><p>在参数前加上校验注解，前提要在类上加入注解@Validated<br>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login2</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span></span></span><br><span class="line"><span class="function">                    @<span class="title">NotBlank</span><span class="params">(message = <span class="string">"邮箱号不能为空"</span>)</span></span></span><br><span class="line"><span class="function">                    @<span class="title">Email</span><span class="params">(message = <span class="string">"邮箱格式不正确"</span>)</span></span></span><br><span class="line"><span class="function">                                String email,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span></span></span><br><span class="line"><span class="function">                        @<span class="title">NotBlank</span><span class="params">(message = <span class="string">"密码不能为空"</span>)</span></span></span><br><span class="line"><span class="function">                        @<span class="title">Size</span><span class="params">(min = <span class="number">5</span>,max = <span class="number">20</span>,message = <span class="string">"密码应该在5~20之间"</span>)</span></span></span><br><span class="line"><span class="function">                                String password)</span>&#123;</span><br><span class="line">                                </span><br><span class="line">    User user = <span class="keyword">new</span> User(email,password);</span><br><span class="line">    <span class="keyword">return</span> loginService.login(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实体类参数校验"><a href="#实体类参数校验" class="headerlink" title="实体类参数校验"></a>实体类参数校验</h5><p>在类的属性上添加校验注解<br>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUserDTO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"必须是邮箱格式啊！！"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"邮箱不能为空啊！！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"密码不能为空啊！！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实体类中的分组处理"><a href="#实体类中的分组处理" class="headerlink" title="实体类中的分组处理"></a>实体类中的分组处理</h5><p>思考：当我有一个方法也要校验LoginUserDTO，但是校验的参数和message不同时，怎么办？<br>解决一：再去定义一个类，编写参数和注解  。 这样很不优雅<br>解决二：使用<strong>参数分组</strong><br>注册一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对LoginUserDTO中的参数进行分组，Default.class是validation-api自带的默认分组类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"必须是邮箱格式啊！！"</span>,groups = Default<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">NotBlank</span>(<span class="title">message</span> </span>= <span class="string">"邮箱不能为空啊！！"</span>,groups = Login<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">email</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空啊！！"</span>,groups = Default<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">password</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义两个方法，在@Validated注解中加入分组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(@RequestBody @Validated(Login.class)</span> LoginUserDTO user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> loginService.login(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login2</span><span class="params">(@RequestBody @Validated(Default.class)</span> LoginUserDTO user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> loginService.login(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>login方法只校验 email的@NotBlank<br>login2方法只校验 email的@Email和password的NotBlank</p><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><p>当校验不成功时产生的异常通过全局异常处理，在有@ControllerAdvice注解的异常处理类中加入以下方法，将其拦截，再将错误信息传输到页面当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>,<span class="title">ConstraintViolationException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">resolveMethodArgumentNotValidException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">    String defaultMessage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//处理在类校验产生的异常</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">        MethodArgumentNotValidException me = (MethodArgumentNotValidException) e;</span><br><span class="line">        defaultMessage = me.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理参数校验产生的异常</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConstraintViolationException) &#123;</span><br><span class="line">        ConstraintViolationException ce = (ConstraintViolationException) e;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = ce.getConstraintViolations();</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(constraintViolations))&#123;</span><br><span class="line">            StringBuilder msgBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(ConstraintViolation constraintViolation :constraintViolations)&#123;</span><br><span class="line">                msgBuilder.append(constraintViolation.getMessage()).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            defaultMessage = msgBuilder.toString();</span><br><span class="line">            <span class="keyword">if</span>(defaultMessage.length()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                defaultMessage = defaultMessage.substring(<span class="number">0</span>,defaultMessage.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorOf(defaultMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResultDTO.errorOf(defaultMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 参数校验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡、选择排序</title>
      <link href="/2020/05/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><ul><li>基本思想: 冒泡排序，类似于水中冒泡，较大的数沉下去，较小的数慢慢冒起来</li><li>假设从小到大，即为较大的数慢慢往后排，较小的数慢慢往前排。</li></ul></blockquote><p>时间复杂度：O(n^2)<br>稳定度：稳定</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>比较相邻的元素，如果前一个比后一个大，两数交换。</li><li>第一趟：第1个和第2个元素比较与交换，随后第2个和第3个比较交换…，直到将最大的数移动到最后一位。</li><li>第二趟将第二大的数移动至倒数第二位</li><li>直到最后一趟完成所有排序</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//总共进行 arr.length-1 排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length -<span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - j - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//比较，大于则交换位置</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>思考</strong><br>假设要排序的 数组为 45 23 21 71 63<br>第一轮 23 21 45 63 <strong>71</strong><br>第二轮 21 23 45 <strong>63 71</strong><br>第三轮 21 23  <strong>45 63 71</strong><br>第四轮 21 <strong>23 45 63 71</strong></p><ul><li>发现：在第二轮的时候结果就已经出来了，第三轮的排序的时候就元素位置就不会发生改变，第四轮则非常多余</li><li>结论：在某一轮<strong>元素位置没有发生变化</strong>时，表示其就是有序的了</li><li>改进  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//临时变量</span></span><br><span class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//标识变量，表示是否进行过交换</span></span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//总共进行 arr.length-1 轮排序</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length-j-<span class="number">1</span>;i++) &#123;</span><br><span class="line">           <span class="comment">//比较，大于则交换位置</span></span><br><span class="line">               <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">                   temp = arr[i];</span><br><span class="line">                   arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                   arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//重置flag，用于下次判断</span></span><br><span class="line">               flag = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020051109485551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvYm9faHVh,size_16,color_FFFFFF,t_70) --></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零</p></blockquote><p>时间复杂度： O(n^2)<br>稳定度：不稳定</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>第一轮：在所有元素中选择出一个最小值，和第1个元素交换<br>第二轮：剩下的元素中找出一个最小值，和第2个元素交换（此时确定了第1个元素是最小值，不参与后面排序）<br>直到最后一趟完成所有排序</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//记录最小值下标</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="comment">//最小值</span></span><br><span class="line">          <span class="keyword">int</span> min = arr[i];</span><br><span class="line">          <span class="comment">//记录最小值下标</span></span><br><span class="line">          <span class="keyword">int</span> minIndex = i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (min&gt;arr[j]) &#123;</span><br><span class="line">                  min = arr[j];</span><br><span class="line">                  minIndex = j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (minIndex!=i) &#123;</span><br><span class="line">              arr[minIndex]=arr[i];</span><br><span class="line">              arr[i] = min;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡和选择排序速度比较"><a href="#冒泡和选择排序速度比较" class="headerlink" title="冒泡和选择排序速度比较"></a>冒泡和选择排序速度比较</h2><p>随机生成 80000 个数字，比较排序时间</p><h3 id="优化后的冒泡排序-vs-选择排序"><a href="#优化后的冒泡排序-vs-选择排序" class="headerlink" title="优化后的冒泡排序 vs 选择排序"></a>优化后的冒泡排序 vs 选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试一下冒泡排序的速度O(n^2),80000个数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">80000</span>;i++) &#123;</span><br><span class="line">           arr[i] = random.nextInt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">       bubbleSort(arr);</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"80000个数据，冒泡排序所花时间："</span>+(end-start));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试一下选择排序的速度O(n^2),80000个数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">           arr[i] = random.nextInt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">       selectSort(arr);</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"80000个数据，选择排序所花时间："</span> + (end - start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/" class="lazyload" data-src="/2020/05/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83.png"  alt="在这里插入图片描述"><br>时间复杂度同样为O(n^2)，但是选择排序速度快于冒泡排序</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2020/05/07/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/05/07/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用稀疏数组"><a href="#为什么要使用稀疏数组" class="headerlink" title="为什么要使用稀疏数组"></a>为什么要使用稀疏数组</h2><p>当我们存储有大量重复元素的二维数组时，如果使用一般的二维数组就造成有<strong>大量重复元素</strong>，很<strong>浪费空间</strong>，<br>例如这个棋盘，如果要记录棋子的位置我们会想到使用二维数组（1代表黑，2代表蓝），当使用普通二维数组时，那些大量重复的0，占用了很大的内存空间。<br>于是我们就可以使用<strong>稀疏数组</strong>来存<strong>储有效数据</strong><br><img src="/" class="lazyload" data-src="/2020/05/07/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%841.jpg"  alt="在这里插入图片描述"></p><h2 id="稀疏数组怎么用"><a href="#稀疏数组怎么用" class="headerlink" title="稀疏数组怎么用"></a>稀疏数组怎么用</h2><p><img src="/" class="lazyload" data-src="/2020/05/07/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%842.jpg"  alt="在这里插入图片描述"></p><p>稀疏数组一共有三列（列固定），分别表示行号、列、值</p><ul><li>第一行：记录初始数组的行、列、有效值个数</li><li>其他行：依次记录有效值的行号、列号、值</li><li>稀疏数组总行数为有效值（假设有效值为num）num+1，列数为3</li></ul><h2 id="思路与实现"><a href="#思路与实现" class="headerlink" title="思路与实现"></a>思路与实现</h2><h3 id="数组转稀疏思路"><a href="#数组转稀疏思路" class="headerlink" title="数组转稀疏思路"></a>数组转稀疏思路</h3><ul><li>先定义好一个二维数组数组，并赋值</li><li>遍历数组，获取有效值个数num</li><li>定义稀疏数组，行数为num+1，列数为3，为数组第一行赋值</li><li>再次遍历初始数组，获取有效值，赋值给稀疏数组</li><li>定义完成</li></ul><h3 id="稀疏数组转二维数组"><a href="#稀疏数组转二维数组" class="headerlink" title="稀疏数组转二维数组"></a>稀疏数组转二维数组</h3><ul><li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</li><li>再读取稀疏数组后几行的数据，并赋值给 原始的二维数组 即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">//0：表示没有棋子，1 黑子  2 蓝字</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = toSparseArray(chessArr1);</span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"得到的稀疏数组"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">"\t "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">        <span class="comment">//将稀疏数组 恢复成 原始的二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = recover(sparseArr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将二维数组 转 稀疏数组的思路</span></span><br><span class="line"><span class="comment">     * 1、先遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] toSparseArray(<span class="keyword">int</span>[][] chessArray)&#123;</span><br><span class="line">        <span class="comment">//有效数的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArray.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = chessArray.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = chessArray.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//用于记录是第几个非0数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArray.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="comment">     * 2、再读取稀疏数组后几行的数据，并赋值给 原始的二维数组 即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sparseArr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] recover(<span class="keyword">int</span>[][] sparseArr)&#123;</span><br><span class="line">        <span class="keyword">int</span> row = sparseArr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> col = sparseArr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> validNum = sparseArr[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;sparseArr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> chessRow = sparseArr[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> chessCol =  sparseArr[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> chessVal = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">            chessArr2[chessRow][chessCol] = chessVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chessArr2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解稀疏数组的使用场景，理解稀疏数组的定义~<br>韩顺平老师的数据结构 打卡第一天！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性：Lambda表达式</title>
      <link href="/2020/05/05/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/05/05/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><p>百度说 “Lambda 表达式”是一个复匿名函数，它可以包含表达式和语句，制并且可用于创建委托或表达式树类型。</p><h2 id="Lambda表达式的优缺点"><a href="#Lambda表达式的优缺点" class="headerlink" title="Lambda表达式的优缺点"></a>Lambda表达式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>代码简洁，开发迅速</li><li>方便函数式编程</li><li>非常容易进行并行计算</li><li>java引入lambda，改善了集合操作（引入Stream API）</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>代码可读性变差</li><li>使得语言学习曲线陡峭，学习难度提升</li><li>性能方面，在非并行计算中，很多计算未必有传统的for性能要高</li><li>不容易进行调试</li></ol><h2 id="体验一下Lambda表达式的便捷"><a href="#体验一下Lambda表达式的便捷" class="headerlink" title="体验一下Lambda表达式的便捷"></a>体验一下Lambda表达式的便捷</h2><h3 id="无优化"><a href="#无优化" class="headerlink" title="无优化"></a>无优化</h3><p><code>需求：获取当前公司中员工年龄大于35岁的员工信息</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">        <span class="comment">//id、name、age、salary</span></span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">35</span>, <span class="number">9999.9</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">2</span>, <span class="string">"李四"</span>, <span class="number">18</span>, <span class="number">18888.0</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">3</span>, <span class="string">"王五"</span>, <span class="number">44</span>, <span class="number">14444.0</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">4</span>, <span class="string">"赵六"</span>, <span class="number">23</span>, <span class="number">2333.0</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">5</span>, <span class="string">"钱七"</span>, <span class="number">47</span>, <span class="number">14244.0</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">6</span>, <span class="string">"陈八"</span>, <span class="number">34</span>, <span class="number">7444.0</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="number">7</span>, <span class="string">"曹九"</span>, <span class="number">39</span>, <span class="number">944.0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一般的做法是,直接写个过滤方法 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; filter = filterEmployee(employees);</span><br><span class="line">    <span class="keyword">for</span> (Employee employee : filter) &#123;</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployee</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee emp : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (emp.getAge() &gt; <span class="number">35</span>) &#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果又增加了需求,又要重新写一个方法，然后直接copy上面的只改一句话，这样代码冗长，繁琐<br><code>新增需求：获取当前公司中员工工资大于5000的员工信息</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployee2</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee emp : list) &#123;</span><br><span class="line">        <span class="comment">//只需改变一句话，其他完全一样，代码冗长</span></span><br><span class="line">        <span class="keyword">if</span> (emp.getSalary() &gt; <span class="number">5000.0</span>) &#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化方式一：引入策略设计模式"><a href="#优化方式一：引入策略设计模式" class="headerlink" title="优化方式一：引入策略设计模式"></a>优化方式一：引入策略设计模式</h3><p>新建一个接口，和一个实现该接口的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------分割线----------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmpByAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employee.getAge()&gt;<span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建方法，如果mp.test(emp)为true，则执行emp添加到新数组，完成过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyPredicate&lt;Employee&gt; mp = <span class="keyword">new</span> FilterEmpByAge();</span><br><span class="line">    List&lt;Employee&gt; employees = filterEmployee(<span class="keyword">this</span>.employees, mp);</span><br><span class="line">    <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployee</span><span class="params">(List&lt;Employee&gt; list, MyPredicate&lt;Employee&gt; mp)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee emp : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.test(emp)) &#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现了新需求，只需要再写一个实现此接口的类，多多少少还是有点繁琐</p><h3 id="优化方式二：匿名内部类"><a href="#优化方式二：匿名内部类" class="headerlink" title="优化方式二：匿名内部类"></a>优化方式二：匿名内部类</h3><p>不用写一个实现此接口的类，直接通过匿名内部类的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyPredicate&lt;Employee&gt; mp = <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> employee.getSalary()&gt;=<span class="number">9797</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Employee&gt; employees = filterEmployee(<span class="keyword">this</span>.employees, mp);</span><br><span class="line">    <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现匿名内部类多多少少还是有点繁琐，毕竟有效代码就一句话<br> <code>return employee.getSalary()&gt;=9797;</code></p><h3 id="优化方式三：lambda表达式"><a href="#优化方式三：lambda表达式" class="headerlink" title="优化方式三：lambda表达式"></a>优化方式三：lambda表达式</h3><p> 使用lambda表达式如下，做到了正在的简洁，只需要把最关键的东西写出来就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployee(employees, (e) -&gt; e.getSalary() &lt;= <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这之后还有一种方式，那就是Stream API</p><h3 id="优化方式四：Stream-API"><a href="#优化方式四：Stream-API" class="headerlink" title="优化方式四：Stream API"></a>优化方式四：Stream API</h3><p>这个极简，连filterEmployee方法都不用写就完成了过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employees.stream()</span><br><span class="line">            .filter(e -&gt; e.getSalary() &gt;= <span class="number">5000</span>) <span class="comment">//过滤</span></span><br><span class="line">            .limit(<span class="number">1</span>) <span class="comment">//限制1个</span></span><br><span class="line">            .forEach(System.out::println); <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式的基本语法"><a href="#Lambda表达式的基本语法" class="headerlink" title="Lambda表达式的基本语法"></a>Lambda表达式的基本语法</h2><p>体验到了Lambda表达式的便捷后，就来康康它的基本语法吧~</p><pre><code>一、Lambda 表达式的基础语法：          &quot;-&gt;&quot; 箭头操作符 或 Lambda 操作符              左侧：Lambda 表达式的参数列表              右侧：Lambda 表达式所需执行的功能，即Lambda体          语法格式一：无参数，无返回值              () -&gt; System.out.println(&quot;Hello World&quot;);          语法格式二：有一个参数，并且无返回值              (e) -&gt; System.out.println(e);              小括号可以不写              e -&gt; System.out.println(e);          语法格式三：有两个以上的参数，有返回值，并且Lambda 体中有多条语句              如果只有一条语句，return和{}都可以省略不写（通用）          语法格式四：Lambda 表达式的参数类型可以省略不写              因为JVM编译器可以通过上下文推断出参数数据类型，叫做”类型推断“         上联：左右遇一括号省         下联：左侧推断类型省         横批：能省就省二、Lambda 表达式需要”函数式接口“的支持   函数式接口：接口中只有一个抽象方法的接口，成为函数式接口      可以在接口上使用注解@FunctionalInterface 修饰，检查接口是否为函数式接口</code></pre><h3 id="内置的四大核心函数式接口"><a href="#内置的四大核心函数式接口" class="headerlink" title="内置的四大核心函数式接口"></a>内置的四大核心函数式接口</h3><p>Consumer<T> ：消费型接口<br>   void accept(T t);</T></p><p>   Supplier<T> ：供给型接口<br>        T get();</T></p><p>   Function&lt;T, R&gt; ：函数型接口<br>        R apply(T t);</p><p>   Predicate<T> ：断言型接口<br>        boolean test(T t);</T></p><h2 id="Lambda表达式中的引用"><a href="#Lambda表达式中的引用" class="headerlink" title="Lambda表达式中的引用"></a>Lambda表达式中的引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用主要有三种语法格式：<br><code>对象::实例方法名</code><br> <code>类::静态方法名</code><br> <code>类::实例方法名</code><br>注意：Lambda 体中调用方法的<strong>参数列表</strong>与<strong>返回值类型</strong>，要与函数式接口中抽象方法的<strong>函数列表</strong>和<strong>返回值类型保持一致</strong>！</p><h4 id="对象-实例方法名"><a href="#对象-实例方法名" class="headerlink" title="对象::实例方法名"></a>对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 例子1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//正常的Lambda表达式</span></span><br><span class="line">       Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">       <span class="comment">//方法引用</span></span><br><span class="line">       <span class="comment">//println为out对象的一个实例方法</span></span><br><span class="line">       PrintStream ps = System.out;</span><br><span class="line">       Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">       Consumer&lt;String&gt; con3 = System.out::println;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 例子2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Employee emp = <span class="keyword">new</span> Employee(<span class="number">1</span>,<span class="string">"niu"</span>,<span class="number">33</span>,<span class="number">49999.0</span>);</span><br><span class="line">       <span class="comment">//正常的Lambda表达式</span></span><br><span class="line">       Supplier&lt;String&gt; sup = () -&gt; emp.getName();</span><br><span class="line">       System.out.println(sup.get());</span><br><span class="line">       <span class="comment">//方法引用</span></span><br><span class="line">       <span class="comment">//getSalary为emp对象的一个实例方法</span></span><br><span class="line">       Supplier&lt;Double&gt; sup2 = emp::getSalary;</span><br><span class="line">       System.out.println(sup2. get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="类-静态方法名"><a href="#类-静态方法名" class="headerlink" title="类::静态方法名"></a>类::静态方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"><span class="comment">//compare是Integer类的静态方法</span></span><br><span class="line">       Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="类-实例方法名"><a href="#类-实例方法名" class="headerlink" title="类::实例方法名"></a>类::实例方法名</h4><p>这个要注意，只有当<strong>第一个参数是实例方法的调用者</strong>，<strong>第二个参数是实例方法的参数</strong>时 才能这样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 类::实例方法名</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 第一个参数是实例方法的调用者，第二个参数是实例方法的参数时 即可这样使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y);</span><br><span class="line">       <span class="comment">//x是equals方法调用者，y为equals方法参数</span></span><br><span class="line">       BiPredicate&lt;String,String&gt; bp2 = String::equals;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="另外，还有构造器引用和数组引用"><a href="#另外，还有构造器引用和数组引用" class="headerlink" title="另外，还有构造器引用和数组引用"></a>另外，还有构造器引用和数组引用</h3><p>如果接口中方法有参数，则调用的构造器参数和接口方法中的参数一致<br>如果没有参数，则调用的无参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造器引用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 如果接口中方法有参数，则调用的构造器参数和接口方法中的参数一致</span></span><br><span class="line"><span class="comment">    * 如果没有参数，则调用的无参构造器</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 例子1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//接口的方法中无参数，调用的无参构造器</span></span><br><span class="line">       Supplier&lt;Employee&gt; sup = ()-&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">       Supplier&lt;Employee&gt; sup1 = Employee::<span class="keyword">new</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//接口的方法中有一个参数，调用的构造器也有一个参数</span></span><br><span class="line">       Function&lt;Integer,Employee&gt; function = Employee::<span class="keyword">new</span>;</span><br><span class="line">       Employee employee = function.apply(<span class="number">1</span>);</span><br><span class="line">       System.out.println(employee);</span><br><span class="line">       <span class="comment">//结果 Employee&#123;id=1, name='null', age=null, salary=null&#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Function&lt;Integer,String[]&gt; fun = (x) -&gt; <span class="keyword">new</span> String[x];</span><br><span class="line"></span><br><span class="line">       Function&lt;Integer,String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">       String[] apply = fun2.apply(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习使我快乐</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap在JDK1.7和1.8的区别</title>
      <link href="/2020/05/04/HashMap%E5%9C%A8JDK1-7%E5%92%8C1-8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/04/HashMap%E5%9C%A8JDK1-7%E5%92%8C1-8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>JDK1.7中，底层使用数组+链表<br>JDK1.8中，底层使用数组+链表+红黑树</p><h2 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h2><h3 id="容量（capacity）：HashMap中数组的长度"><a href="#容量（capacity）：HashMap中数组的长度" class="headerlink" title="容量（capacity）：HashMap中数组的长度"></a>容量（capacity）：HashMap中数组的长度</h3><ol><li>容量范围：必须是2的幂 &amp; &lt;最大容量（2的30次方）</li><li>初始容量 = 哈希表创建时的容量</li><li>默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16<br><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code></li><li>最大容量 = 2的30次方（若传入的容量过大，将被最大值替换）<br><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li></ol><h3 id="加载因子-Load-factor-：HashMap在其容量自动增加前可达到多满的一种尺度"><a href="#加载因子-Load-factor-：HashMap在其容量自动增加前可达到多满的一种尺度" class="headerlink" title="加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度"></a>加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度</h3><ol><li>加载因子越大、填满的元素越多 = 空间利用率高、但冲突的机会加大、查找效率变低（因为链表变长了）</li><li>加载因子越小、填满的元素越少 = 空间利用率小、冲突的机会减小、查找效率高（链表不长）</li><li>默认加载因子 = 0.75<br><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></li></ol><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ol><li><p>扩容时resize(2 * table.length)，扩容到原数组长度的2倍。</p></li><li><p>若key == null，则hash(key) = 0，则将该键-值 存放到数组table 中的第1个位置，即table [0]</p></li></ol><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><h3 id="JDK1-7中"><a href="#JDK1-7中" class="headerlink" title="JDK1.7中"></a>JDK1.7中</h3><ul><li><p>使用一个<strong>Entry数组</strong>来存储数据,用key的hashcode取模来决定key会被放到数组里的位置,如果hashcode相同,或者hashcode取模后的结果相同(hash collision),那么这些key会被定位到Entry数组的同一个格子里,这些key会形成一个链表。</p></li><li><p>在hashcode特别差的情况下,比方说所有key的hashcode都相同,这个链表可能会很长,那么put/get操作都可能需要遍历这个链表</p></li><li><p>,也就是说时间复杂度在最差情况下会退化到<strong>O(n)</strong>。</p></li><li><p>发生hash冲突时，新元素插入到链表头中，即新元素总是添加到数组中，就元素移动到链表中。</p></li><li><p>在扩容resize（）过程中，采用单链表的<strong>头插法</strong>，在将旧数组上的数据 转移到 新数组上时，转移操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况 。</p></li><li><p>HashMap线程不安全的一个重要原因就是：多线程下resize()容易出现死循环，此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则 容易出<br>现 环形链表，从而在get数据、遍历链表时 <strong>形成死循环（Infinite Loop），即 死锁的状态 。</strong></p></li></ul><h3 id="JDK1-8中"><a href="#JDK1-8中" class="headerlink" title="JDK1.8中"></a>JDK1.8中</h3><ul><li><p>使用一个<strong>Node数组</strong>来存储数据,但这个Node可能是链表结构,也可能是红黑树结构</p></li><li><p>如果插入的key的hashcode相同,那么这些key也会被定位到Node数组的同一个格子里。</p></li><li><p>如果同一个格子里的key不超过8个,使用链表结构存储。</p></li><li><p>如果超过了8个,那么会调用treeifyBin函数,将链表转换为红黑树。</p></li><li><p>那么即使hashcode完全相同,由于红黑树的特点,查找某个特定元素,也只需要O(log n)的开销</p></li><li><p>也就是说put/get的操作的时间复杂度最差只有<strong>O(log n)</strong></p></li><li><p>由于 JDK 1.8 转移数据操作 = 按旧链表的正序遍历链表、<strong>在新链表的尾部依次插入（尾插法）</strong>，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况 ，但jdk1.8仍是线程不安全的，因为没有加同步锁保护。</p></li><li><p>发生hash冲突后，会优先判断该节点的数据结构式是红黑树还是链表，如果是红黑树，则在红黑树中插入数据，如果是链表，则将数据插入到链表的尾部并判断链表长度是否大于8，如果大于8要转成红黑树，另一还要判断数组长度是否超过阀值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写ArrayList（仿照源码）</title>
      <link href="/2020/04/29/%E6%89%8B%E5%86%99ArrayList/"/>
      <url>/2020/04/29/%E6%89%8B%E5%86%99ArrayList/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList简述"><a href="#ArrayList简述" class="headerlink" title="ArrayList简述"></a>ArrayList简述</h2><p>ArrayList底层使用的是<strong>数组</strong>，相对于LinkeList来说查询<strong>修改快，增删慢</strong>，适用于查询较多的场景。<strong>非线程安全。</strong></p><ol><li>List 接口： List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合</li><li>AbstractList 类： List接口的骨架实现类，最小化实现了List接口所需要实现的工作量</li><li>实现了Cloneable接口，即覆盖了函数clone()，能克隆;</li><li>实现了Cloneable接口，实现了该接口标示了类可以被序列化和反序列化</li><li>RandomAccess 接口，实现了该接口的类支持快速随机访问</li></ol><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//初始的数组（空数组）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//底层数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">//包含的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h3 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否对数组进行扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//此时数组长度已扩容或长度够不需要扩容</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确保内部容量</span></span><br><span class="line"><span class="comment">     * 判断数组的容量，小于minCapacity就进行扩容1.5倍</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是空数组则 minCapacity = 10</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//原数组容量</span></span><br><span class="line">            <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">            <span class="comment">//扩容为之前的1.5倍（扩容因子为1.5）</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果新容量 小于 最小容量，则新容量 = 最小容量</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ArrayList最大数组长度为Integer.MAX_VALUE - 8</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; (Integer.MAX_VALUE - <span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                &#125;</span><br><span class="line">                newCapacity = (minCapacity &gt; Integer.MAX_VALUE - <span class="number">8</span>) ? Integer.MAX_VALUE : Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建新长度的数组，并将原数组数据赋值给新数组</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素至索引处，索引处和其之后的元素全部后挪一位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index不合法+ index:"</span> + index + <span class="string">",size:"</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否需要扩容,true-&gt;扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//size-(index+1)+1</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将集合e中的元素放到数组中</span></span><br><span class="line">        Object[] a = e.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//将新数组添加到底层数组的尾部</span></span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,elementData,size,numNew);</span><br><span class="line">        size +=numNew;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据索引查询（数组的随机查询，效率高）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法（是否越界）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">        <span class="comment">//返回查询的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查给定索引是否在数组的有效范围内</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index不合法！！index:"</span> + index + <span class="string">",size:"</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引修改元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否合法（是否越界）</span></span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       E oldValue = (E) elementData[index];</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引删除元素，并将其之后的元素向前移一位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       E oldValue = (E) elementData[index];</span><br><span class="line">       <span class="comment">//要改变下标的元素个数 size-（index+1）</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//从elementData数组的下标index+1开始，覆盖到从elementData数组的下标index的位置</span></span><br><span class="line">           System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尾部的元素设置为null，size先-- 再使用</span></span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据元素删除，遍历数组找到第一个于 o == 的元素 获取他的索引将其删除</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   remove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                   remove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.clh.test.mylist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写ArrayList，底层是数组（Array），在查询大量数据时for遍历效率大于Iterator</span></span><br><span class="line"><span class="comment"> * 特点：查询快，增删慢 线程不安全 效率高</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 华华</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始的数组（空数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底层数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建MyArrayList对象时，并且使elementData为默认长度（空）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">(Collection&lt;? extends E&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否对数组进行扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确保内部容量</span></span><br><span class="line"><span class="comment">     * 判断数组的容量，小于minCapacity就进行扩容1.5倍</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是空数组则 minCapacity = 10</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//原数组容量</span></span><br><span class="line">            <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">            <span class="comment">//扩容为之前的1.5倍（扩容因子为1.5）</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果新容量 小于 最小容量，则新容量 = 最小容量</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ArrayList最大数组长度为Integer.MAX_VALUE - 8</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; (Integer.MAX_VALUE - <span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                &#125;</span><br><span class="line">                newCapacity = (minCapacity &gt; Integer.MAX_VALUE - <span class="number">8</span>) ? Integer.MAX_VALUE : Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建新长度的数组，并将原数组数据赋值给新数组</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素至索引处，索引处和其之后的元素全部后挪一位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index不合法+ index:"</span> + index + <span class="string">",size:"</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否需要扩容,true-&gt;扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//size-(index+1)+1</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; e)</span> </span>&#123;</span><br><span class="line">        Object[] a = e.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//将新数组添加到底层数组的尾部</span></span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,elementData,size,numNew);</span><br><span class="line">        size +=numNew;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引查询（数组的随机查询，效率高）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法（是否越界）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">        <span class="comment">//返回查询的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定索引是否在数组的有效范围内</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index不合法！！index:"</span> + index + <span class="string">",size:"</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法（是否越界）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引删除元素，并将其之后的元素向前移一位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        <span class="comment">//要改变下标的元素个数 size-（index+1）</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从elementData数组的下标index+1开始，覆盖到从elementData数组的下标index的位置</span></span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾部的元素设置为null，size先-- 再使用</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据元素删除，遍历数组找到第一个于 o == 的元素 获取他的索引将其删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    remove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    remove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多场景下ArrayList更受欢迎，但是还有些情况下LinkedList更为合适。譬如：</p><ol><li><p>你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。</p></li><li><p>你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</p></li></ol><p>上述是关于ArrayList和LinkedList的差别。当需要一个不同步的基于索引的数据访问时，请尽量使用ArrayList。但是要记得要给定一个合适的初始大小，尽可能的减少更改数组的大小。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2020/04/28/java%E9%9B%86%E5%90%88/"/>
      <url>/2020/04/28/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ol><li>简而言之，集合就是一个放数据的容器，准确的说是放数据对象引用的容器。<br>集合不能放基本数据类型只能放对象，而数组时可以放所有数据。<br>集合存放的都是对象的引用，而非对象本身。所以我们称集合中的对象就是集合中对象的引用。</li><li>java集合类存放于java.util包中。</li><li>集合类型主要有3种：Set(集）、List(列表）和Map(映射)，List和Set继承了Collection。</li><li>List集合中常用的有ArrayList、Vector和LinkedList</li><li>Set集合中常用的是HashSet和TreeSet</li><li>Map集合中常用的是HashMap和Hashtable<br><img src="/" class="lazyload" data-src="/2020/04/28/java%E9%9B%86%E5%90%88/Collection.png"  alt="Collection"><br><img src="/" class="lazyload" data-src="/2020/04/28/java%E9%9B%86%E5%90%88/map.png"  alt="Map"></li></ol><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>有序可重复，存储的元素有下标</p><h3 id="List常用的实现类"><a href="#List常用的实现类" class="headerlink" title="List常用的实现类"></a>List常用的实现类</h3><table><thead><tr><th>List实现类</th><th>底层</th><th>速度</th><th>效率</th><th>线程安全</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组</td><td>查询快,增删慢</td><td>高</td><td>否</td></tr><tr><td>Vector</td><td>数组</td><td>查询快,增删慢</td><td>低</td><td>是</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>查询慢,增删快</td><td>高</td><td>否</td></tr></tbody></table><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>无序不可重复</p><h3 id="Set常用的实现类"><a href="#Set常用的实现类" class="headerlink" title="Set常用的实现类"></a>Set常用的实现类</h3><table><thead><tr><th>Set实现类</th><th>底层</th><th>特点</th></tr></thead><tbody><tr><td>HashSet</td><td>HashMap(底层为哈希表)</td><td>放到HashSet中的元素相当于放到HashMap中的Key</td></tr><tr><td>TreeSet</td><td>TreeMap(底层为二叉树)</td><td>放到TreeSet中的元素相当于放到TreeMap中的Key</td></tr></tbody></table><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol><li>Map集合和Collection集合没有关系</li><li>Map集合以key和value的这种键值对的方式存储元素</li><li>key和value都是存储java对象的内存地址</li><li>所有Map集合的key都是无序不可重复</li></ol><h3 id="Map常用的实现类"><a href="#Map常用的实现类" class="headerlink" title="Map常用的实现类"></a>Map常用的实现类</h3><table><thead><tr><th>Map实现类</th><th>底层</th><th>线程安全</th></tr></thead><tbody><tr><td>HashMap</td><td>哈希表</td><td>否</td></tr><tr><td>Hashtable</td><td>哈希表</td><td>是</td></tr><tr><td>TreeMap</td><td>二叉树</td><td>否</td></tr><tr><td>Properties(继承Hashtable)</td><td>哈希表</td><td>线程安全</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写LinkedList（仿照源码）</title>
      <link href="/2020/04/28/%E6%89%8B%E5%86%99LinkedList/"/>
      <url>/2020/04/28/%E6%89%8B%E5%86%99LinkedList/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList简述"><a href="#LinkedList简述" class="headerlink" title="LinkedList简述"></a>LinkedList简述</h2><p><code>LinkedList</code>底层使用一个<strong>Node数据结构</strong>，有前后两个指针，<strong>双向链表</strong>实现的。相对数组，链表插入效率较高，只需要更改前后两个指针即可；另外链表不存在扩容问题，因为链表不要求存储空间连续，每次插入数据都只是改变last指针；另外，链表所需要的内存比数组要多，因为他要维护前后两个指针；它适合删除，插入较多的场景。</p><p><code>LinkedList</code>是一个继承于<code>AbstractSequentialList</code>的双向链表。</p><ol><li>它也可以被当作堆栈、队列或双端队列进行操作;</li><li>继承了<code>AbstractSequentialList</code>,这个类提供了一个基本的List接口实现，为实现序列访问的数据储存结构的提供了所需要的最小化的接口实现。对于支持随机访问数据的List比如数组，应该优先使用AbstractList。</li><li>实现 List 接口，List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合;</li><li>实现 Deque 接口，即能将LinkedList当作双端队列使用;</li><li>实现了Cloneable接口，即覆盖了函数clone()，能克隆;</li><li>实现java.io.Serializable接口，支持序列化;<br>非同步;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>在MyLinkedList类中定义Node节点类（静态内部类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//前节点   </span></span><br><span class="line"> Node&lt;E&gt; prev;</span><br><span class="line"> <span class="comment">//当前节点</span></span><br><span class="line"> E item;</span><br><span class="line"> <span class="comment">//后节点</span></span><br><span class="line"> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.item = item;</span><br><span class="line">     <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     <span class="keyword">this</span>.next = next;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="定义MyLinkedList的属性"><a href="#定义MyLinkedList的属性" class="headerlink" title="定义MyLinkedList的属性"></a>定义MyLinkedList的属性</h3><p>size（长度）、first（头节点）、last（尾节点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//链表的头部   </span></span><br><span class="line">    Node&lt;E&gt; first;</span><br><span class="line">     <span class="comment">//链表的尾部</span></span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义增删改查方法"><a href="#定义增删改查方法" class="headerlink" title="定义增删改查方法"></a>定义增删改查方法</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在链表尾部插入</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//创造节点，将节点连接链表</span></span><br><span class="line">       Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(last, e, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//链表连接节点</span></span><br><span class="line">       <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//链表为空</span></span><br><span class="line">           <span class="comment">//新节点赋值给头节点</span></span><br><span class="line">           first = newNode;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//链表不为空</span></span><br><span class="line">           <span class="comment">//将当前链表last的下一个节点指向新节点（连接）  last--&gt;newNode</span></span><br><span class="line">           last.next = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将新节点变为尾节点</span></span><br><span class="line">       last = newNode;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引插入</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当前索引下的节点</span></span><br><span class="line">       Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">       <span class="comment">//前继节点</span></span><br><span class="line">       Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">       <span class="comment">//创建新节点并连接链表</span></span><br><span class="line">       Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(prev, e, succ);</span><br><span class="line">       <span class="comment">//将链表连接新节点</span></span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//如果prev为空，则表示链表为空，则新节点赋值给首节点</span></span><br><span class="line">           first = newNode;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//prev的前节点连接新节点</span></span><br><span class="line">           prev.next = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将集合c中数据在链表末尾添加</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将集合c中数据在链表指定位置添加</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否合法</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> &amp;&amp; index &gt; size) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"指定的位置不合法："</span> + index);</span><br><span class="line">       &#125;</span><br><span class="line">       Object[] items = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> length = items.length;</span><br><span class="line">       <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Node&lt;E&gt; succ, prev;</span><br><span class="line">       <span class="comment">//获得当前索引下的节点和前节点</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">           succ = <span class="keyword">null</span>;</span><br><span class="line">           prev = last;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           succ = getNode(index);</span><br><span class="line">           prev = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//插入</span></span><br><span class="line">       <span class="keyword">for</span> (Object item : items) &#123;</span><br><span class="line">           E e = (E) item;</span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(prev, e, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">               first = newNode;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               prev.next = newNode;</span><br><span class="line">           &#125;</span><br><span class="line">           prev = newNode;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义尾节点</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           prev.next = succ;</span><br><span class="line">           succ.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">       size += length;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引获取节点</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Node&lt;E&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先判断index是否合法</span></span><br><span class="line">       <span class="comment">//size&gt;&gt;1 相当于 size/(2的1次方)</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">           <span class="comment">//从头部开始找</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">               x = x.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从尾部开始找</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">               x = x.prev;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引查询数据</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先判断index是否合法</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> getNode(index).item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据索引修改</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回先前位于指定位置的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//获取当前索引下的节点，并且修改为新数据</span></span><br><span class="line">       Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">       E oldVal = succ.item;</span><br><span class="line">       succ.item = e;</span><br><span class="line">       <span class="keyword">return</span> oldVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//当前索引下的节点</span></span><br><span class="line">    Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">    <span class="comment">//前继节点</span></span><br><span class="line">    Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">    <span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; next = succ.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//删除的为头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        succ.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//删除的为尾节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        succ.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> succ.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现代码（全）"><a href="#实现代码（全）" class="headerlink" title="实现代码（全）"></a>实现代码（全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.clh.test.mylist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写LinkedList</span></span><br><span class="line"><span class="comment"> * LinkedList是java中的双向链表， 是List接口链表的实现，特点是增删快，查找慢。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 华华</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将集合c中数据在链表末尾添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将集合c中数据在链表指定位置添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> &amp;&amp; index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"指定的位置不合法："</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] items = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> length = items.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; succ, prev;</span><br><span class="line">        <span class="comment">//获得当前索引下的节点和前节点</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            prev = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = getNode(index);</span><br><span class="line">            prev = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        <span class="keyword">for</span> (Object item : items) &#123;</span><br><span class="line">            E e = (E) item;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(prev, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                first = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = newNode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = succ;</span><br><span class="line">            succ.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        size += length;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在链表尾部插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创造节点，将节点连接链表</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(last, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//链表连接节点</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//表示链表为空时新节点赋值给首节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将当前链表last的下一个节点指向新节点（连接）  last--&gt;newNode</span></span><br><span class="line">            last.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新节点变为尾节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">        Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(prev, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引查询数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断index是否合法</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> getNode(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引获取节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断index是否合法</span></span><br><span class="line">        <span class="comment">//size&gt;&gt;1 相当于 size/(2的1次方)</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//从头部开始找</span></span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                x = x.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从尾部开始找</span></span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">                x = x.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断参数是否为当前链表的索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index不合法！！index:"</span> + index + <span class="string">",size:"</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回先前位于指定位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">        E oldVal = succ.item;</span><br><span class="line">        succ.item = e;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; succ = getNode(index);</span><br><span class="line">        Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">        Node&lt;E&gt; next = succ.next;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            succ.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            succ.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> succ.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        <span class="comment">//当前节点</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//后节点</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LinkedList</code>的插入思路就是将新节点连接链表、再将链表连接新节点，如果是根据索引插入就要判断索引是否合法，是否在首部或尾部进行插入。删改查都差不多</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot实现邮件登录注册</title>
      <link href="/2020/04/19/Email/"/>
      <url>/2020/04/19/Email/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Spring-Boot完成邮箱登录注册"><a href="#使用Spring-Boot完成邮箱登录注册" class="headerlink" title="使用Spring Boot完成邮箱登录注册"></a>使用Spring Boot完成邮箱登录注册</h2><p>源码：<a href="https://github.com/Hobo-clh/spring-boot-email" target="_blank" rel="noopener">https://github.com/Hobo-clh/spring-boot-email</a></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>主要记录一下邮箱注册，使用Spring Boot和MyBatis</p><ol><li>springboot中导入email相关依赖</li><li>开启邮箱的POP3/SMTP服务（这里使用的是qq邮箱）文档</li><li>在springboot的配置文件中添加email相关配置</li></ol><h3 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h3><ul><li>获取验证码：填写邮箱号后点击发送验证码按钮–&gt;发送ajax请求–&gt;后端生成验证码发送邮件，生成一个验证对象插入验证表中，使用多线程五分钟后删除改信息。</li><li>注册： 点击注册按钮–&gt;发送ajax请求–&gt;后端判断验证码是否正确–&gt;返回json数据–&gt;注册是否成功</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li><p><strong>目录结构</strong><br><img src="/" class="lazyload" data-src="/2020/04/19/Email/structure.png"  alt="目录结构"></p></li><li><p>在idea中创建Spring Boot工程<br>  在pom.xml 配置文件中加入spring-boot-starter-mail 依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在springboot配置文件application.yml中添加邮箱配置信息</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#邮件相关配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">longhuahobo@foxmail.com</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">qq邮箱是授权码</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">  <span class="comment"># SMTP服务</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">mail:</span></span><br><span class="line">      <span class="attr">smtp:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">socketFactory:</span></span><br><span class="line">          <span class="attr">class:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">465</span></span><br></pre></td></tr></table></figure></li><li><p>model层User和Verify实体类，数据库创建相对应的表</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.model;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.model;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临时验证码存放表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Verify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当进行注册的业务逻辑时，会出现一些错误信息，例如邮箱号为空、验证码为空等，要将这些信息精准的返回给用户则需要添加一个enum类，对这些错误信息进行定义</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义枚举类,将错误信息定义为枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CustomizeErrorCode &#123;</span><br><span class="line">    EMAIL_IS_EXIST(<span class="number">201</span>,<span class="string">"邮箱已经注册过了"</span>),</span><br><span class="line">    EMAIL_IS_BLANK(<span class="number">202</span>,<span class="string">"邮箱不能为空"</span>),</span><br><span class="line">    EMAIL_OR_PWD_BLANK(<span class="number">203</span>,<span class="string">"邮箱或密码不能为空"</span>),</span><br><span class="line">    INVALID_ADDRESSES(<span class="number">204</span>,<span class="string">"无效的地址！"</span>),</span><br><span class="line">    VERIFY_IS_ERROR(<span class="number">205</span>,<span class="string">"验证码错误"</span>),</span><br><span class="line">    REGISTER_FAIL(<span class="number">206</span>,<span class="string">"注册失败"</span>),</span><br><span class="line">    EMAIL_OR_PWD_ERROR(<span class="number">206</span>,<span class="string">"邮箱号或密码错误，登录失败"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    CustomizeErrorCode(Integer code,String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将错误信息封装到dto层的ResuDTO中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot.exception.CustomizeErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将CustomizeErrorCode枚举对象的值转换给ResultDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorCode 枚举对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultDTO <span class="title">errorInfo</span><span class="params">(CustomizeErrorCode errorCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init(errorCode.getCode(),errorCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ResultDTO对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 描述信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ResultDTO <span class="title">init</span><span class="params">(Integer code,String message)</span></span>&#123;</span><br><span class="line">        ResultDTO resultDTO = <span class="keyword">new</span> ResultDTO();</span><br><span class="line">        resultDTO.setCode(code);</span><br><span class="line">        resultDTO.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> resultDTO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultDTO <span class="title">info</span><span class="params">(Integer code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init(code,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>controller层的RegisterController</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot.dto.ResultDTO;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.exception.CustomizeErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.service.RegisterService;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">registerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RegisterService registerService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册</span></span><br><span class="line"><span class="comment">     * 将注册参数code、email、pwd封装带UserDTO中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResultDTO 返回json格式，带有code和message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDTO <span class="title">register</span><span class="params">(UserDTO userDTO)</span></span>&#123;</span><br><span class="line">        System.out.println(userDTO);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(userDTO.getEmail())&amp;&amp;StringUtils.isBlank(userDTO.getPassword()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.EMAIL_OR_PWD_BLANK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> registerService.register(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResultDTO 返回json格式，带有code和message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/sendCode"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDTO <span class="title">sendCode</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email)</span>&#123;</span><br><span class="line">        System.out.println(email);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(email))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.EMAIL_IS_BLANK);</span><br><span class="line">        &#125;</span><br><span class="line">        ResultDTO resultDTO = registerService.sendCode(email);</span><br><span class="line">        <span class="keyword">if</span> (resultDTO.getCode()==<span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">//多线程五分钟后删除</span></span><br><span class="line">            registerService.removeCode(email);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service层的RegisterService，创建多线程将发送的验证码在5分钟后进行删除（使用“@Async”时需要在Spring Boot启动类使用“@EnableAsync”）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot.dto.ResultDTO;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.exception.CustomizeErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.mapper.VerifyMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.model.User;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot.model.Verify;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.MailException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.SimpleMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    VerifyMapper verifyMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查邮箱号是否注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRegister</span><span class="params">(String email)</span></span>&#123;</span><br><span class="line">        User user1 = userMapper.selectByEmail(email);</span><br><span class="line">        <span class="keyword">if</span> (user1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDTO 该对象参数含有email、pwd、code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResultDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDTO <span class="title">register</span><span class="params">(UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//checkRegister()返回结果为true表示可以注册</span></span><br><span class="line">        <span class="keyword">if</span> (!checkRegister(userDTO.getEmail()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.EMAIL_IS_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        userDTO.getCode();</span><br><span class="line">        Verify verify = verifyMapper.selectVerify(userDTO.getCode(),userDTO.getEmail());</span><br><span class="line">        <span class="keyword">if</span> (verify==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//验证码错误</span></span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.VERIFY_IS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setEmail(userDTO.getEmail());</span><br><span class="line">        user.setPassword(userDTO.getPassword());</span><br><span class="line">        <span class="keyword">int</span> flag = userMapper.insert(user);</span><br><span class="line">        <span class="comment">//注册成功</span></span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//登录成功将验证码删除</span></span><br><span class="line">            verifyMapper.deleteByEmail(userDTO.getEmail());</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.info(<span class="number">200</span>,<span class="string">"注册成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注册失败</span></span><br><span class="line">        <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.REGISTER_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResultDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDTO <span class="title">sendCode</span><span class="params">(String email)</span></span>&#123;</span><br><span class="line">        <span class="comment">//随机六位数验证码</span></span><br><span class="line">        <span class="keyword">if</span> (!checkRegister(email))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.EMAIL_IS_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">            <span class="keyword">int</span> code = (<span class="keyword">int</span>)((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">            message.setSubject(<span class="string">"Hobo社区验证码"</span>);</span><br><span class="line">            message.setText(<span class="string">"欢迎加入Hobo社区！ 您的验证码是："</span>+ code + <span class="string">"，请在5分钟内完成注册。"</span>);</span><br><span class="line">            message.setTo(email);</span><br><span class="line">            message.setFrom(<span class="string">"longhuahobo@foxmail.com"</span>);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            Verify verify = <span class="keyword">new</span> Verify();</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            verify.setCode(code);</span><br><span class="line">            verify.setEmail(email);</span><br><span class="line">            verifyMapper.insert(verify);</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.info(<span class="number">200</span>,<span class="string">"邮件发送成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MailException e)&#123;</span><br><span class="line">            log.error(<span class="string">"邮件发送出错"</span> + e);</span><br><span class="line">            <span class="keyword">return</span> ResultDTO.errorInfo(CustomizeErrorCode.INVALID_ADDRESSES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用多线程五分钟后清除验证码数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email email</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCode</span><span class="params">(String email)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">5</span>);</span><br><span class="line">            verifyMapper.deleteByEmail(email);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper层的UserMapper、VerifyMapper，使用注解方式对数据库进行增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot.model.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入用户表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 用户，带有email、password参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user(email,password) values(#&#123;email&#125;,#&#123;password&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用id查找用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用邮箱号和密码查找用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password  密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where email = #&#123;email&#125; and password = #&#123;password&#125; "</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectByEmailPwd</span><span class="params">(String email, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用邮箱号查找用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where email = #&#123;email&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectByEmail</span><span class="params">(String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot.model.Verify;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VerifyMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入验证表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verify 带有email和code参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into verify(email,code) values(#&#123;email&#125;,#&#123;code&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Verify verify)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用验证码和邮箱号查找验证表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from verify where code = #&#123;code&#125; and email = #&#123;email&#125;"</span>)</span><br><span class="line">    <span class="function">Verify <span class="title">selectVerify</span><span class="params">(String code,String email)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用邮箱号删除验证表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 邮箱号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from verify where email = #&#123;email&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByEmail</span><span class="params">(String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码省略….<br><img src="/" class="lazyload" data-src="/2020/04/19/Email/result.png"  alt="result"><br><img src="/" class="lazyload" data-src="/2020/04/19/Email/result2.png"  alt="result2">    </p></li></ul><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Email </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的过滤器</title>
      <link href="/2020/04/05/jQuery%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/04/05/jQuery%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本属性过滤器"><a href="#1、基本属性过滤器" class="headerlink" title="1、基本属性过滤器"></a>1、基本属性过滤器</h2><ul><li><p>获取–属性名等于指定值的元素<br>$(“选择器[属性名=值]”)</p></li><li><p>获取–不含指定值的元素<br>$(“选择器[属性名!=’值’]”) </p></li><li><p>获取–指定值开始的元素<br>$(“选择器[属性名^=’值’]”）</p></li><li><p>获取–指定值结束的元素<br>$(“选择器[属性名$=’值’]”）</p></li><li><p>获取–包含指定值的元素<br>$(“选择器[属性名*=’值’]”)</p></li></ul><p><strong>复合属性过滤器</strong><br> $ ([属性过滤器 1] [属性过滤器 2]……[属性过滤器 n]) </p><h2 id="基本过滤器"><a href="#基本过滤器" class="headerlink" title="基本过滤器"></a>基本过滤器</h2><ul><li><p>获取选择器的第一个元素<br>$(“选择器:first”) </p></li><li><p>获取选择器的最后一个元素<br>$(“选择器:last”) </p></li><li><p>$(“选择器:not()”)<br>获取not过滤器可以去除所有与给的选择器匹配的元素<br>例如:<br>$(“div :not([id])”)，除去含有id属性的div<br>$(“li :not(:first)”)，除去第一个li元素</p></li><li><p>$(“选择器:even”)<br>获取索引值为偶数的元素</p></li><li><p>$(“选择器:odd”)<br>获取索引值为奇数的元素</p></li><li><p>$(“选择器:eq(2)”)<br>获取索引值为2的元素</p></li><li><p>$(“选择器:gt(2)”)<br>获取索引值大于2的元素</p></li><li><p>$(“选择器:it(3)”)<br>获取索引值小于3的元素</p></li><li><p>$(“选择器:header”)<br>选择所有 h1、h2、h3 一类的header 标签</p></li></ul><h2 id="内容过滤器："><a href="#内容过滤器：" class="headerlink" title="内容过滤器："></a>内容过滤器：</h2><ul><li><p>contains()<br>使用 :contains() 过滤器可以匹配包含指定文本的元素。<br>例如：$(“div:contains(HTML)”) 可以选择内容包含 HTML 的 div 元素。</p></li><li><p>empty()<br>例如：使用 $(“td:empty”)可以选择内容为空的表格单元格。</p></li><li><p>has()<br>例如： $(“p”).has(“span”)<br>返回拥有一个span元素在其内的所有p元素</p></li><li><p>parent()<br>$(“p”).parent(“.selected”)<br>返回class为selected的p元素</p></li></ul><h2 id="子元素过滤器"><a href="#子元素过滤器" class="headerlink" title="子元素过滤器"></a>子元素过滤器</h2><ul><li><p>nth-child(index/even/odd/eq)<br>$ (“ul li:nth-child(2)”) 可以匹配 ul 元素中的第2个 li 子元素，<br>$ (“ul li:nth-child(even)”) 可以匹配 ul 元素中的第偶数个 li 子元素。</p></li><li><p>first-child<br>可以使用 :first-child 过滤器匹配第一个子元素<br>$ (“ul li:first-child”) 可以匹配 ul 列表中的第一个 li 子元素。</p></li><li><p>last-child<br>:last-child 过滤器匹配最后一个子元素。<br>$ (“ul li:last-child”) 可以匹配 ul 列表中的最后一个 li 子元素。</p></li><li><p>only-child<br>可以使用 :only-child 过滤器匹配父元素的唯一子元素。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结一下jQuery的过滤器，以后如果用到了又忘记了就翻翻这篇博客</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Spring Boot的小型论坛项目</title>
      <link href="/2020/04/04/Boot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/04/04/Boot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>项目地址： <strong><a href="http://hobosocool.top:81/" target="_blank" rel="noopener">Hobo社区</a></strong><br>服务器：阿里云CentOS7</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><ul><li><p>后端Spring Boot、MyBatis、mysql</p></li><li><p>前端使用BootStrap框架、thymeleaf模板引擎</p></li><li><p>使用了flyway管理数据库版本，方便迁移数据库</p></li><li><p>使用MyBatis Generator自动生成mapper、model、xml文件，一般情况下不用再写sql语句了，极大地提高了开发效率</p></li><li><p>整合了mail，完成发送邮件功能</p></li><li><p>第三方工具<br>使用了<a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">EditorMarkdown编辑器</a>，支持md语法，并且支持上传<br>使用了阿里云对象存储OSS管理上传的图片</p></li></ul><h2 id="项目功能介绍"><a href="#项目功能介绍" class="headerlink" title="项目功能介绍"></a>项目功能介绍</h2><ul><li><p>登录功能：使用<a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">GitHub第三方登录</a>和<a href="https://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0" target="_blank" rel="noopener">QQ第三方登录</a>，也可以表单邮箱注册登录</p></li><li><p>表单注册登录支持密码修改</p></li><li><p>提问：支持markdown语法</p></li><li><p>点赞、评论、二级评论</p></li><li><p>通知功能：点赞、评论或者二级评论后，会产生通知</p></li><li><p>热门标签：使用Spring Schedule定时任务，定时计算出标签的热度</p></li><li><p>相关问题：通过正则匹配标签，只要含有当前文章的其中一个标签，都会被列为相关问题</p><table><thead><tr><th>模式</th><th>模式匹配</th></tr></thead><tbody><tr><td>tag1 | tag2 | tag3</td><td>交替匹配任何模式tag1，tag2或tag3</td></tr></tbody></table></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学完Spring Boot的入门视频不久，想找一个项目练练手，就在B站上看到了码匠笔记的论坛项目教学。这就是一个不算复杂的练手项目，B站上跟着码匠笔记学习的，让我简单熟悉了Spring Boot的开发流程，，之后可能会添加一些新功能或集成一些新框架，加油吧~！</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven-解决新建spring boot项目导入jar包失败的问题</title>
      <link href="/2020/03/17/maven-bug%E4%BF%AE%E5%A4%8D/"/>
      <url>/2020/03/17/maven-bug%E4%BF%AE%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><ul><li><p>新建springboot项目时无法导入jar包</p></li><li><p>尝试在maven的settings文件中修改maven镜像–&gt;<strong>没用</strong></p></li><li><p>尝试更换maven版本–&gt;<strong>没用</strong></p></li><li><p>如何查看查看log日志发现是</p></li></ul><blockquote><p>java.lang.RuntimeException: sun.security.provider.certpath.SunCertPathBuilderException:<br>        unable to find valid certification path to requested target<br>        找不到请求目标的有效证书路径</p></blockquote><ul><li>此时就轮到度娘上场了</li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li><p>下载证书保存在本地，在jdk-&gt;jre-&gt;lib-&gt;security中打开命令行,输入以下命令将证书添加在java证书库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool <span class="literal">-import</span> <span class="literal">-alias</span> cacerts <span class="literal">-keystore</span> cacerts <span class="operator">-file</span> &lt;证书路径&gt;</span><br><span class="line"><span class="comment"># 默认密匙changeit</span></span><br></pre></td></tr></table></figure></li><li><p>此时打开idea发现还是下载失败</p></li><li><p>在idea中，打开项目路径下的命令行，执行命令让maven绕过校验服务器的证书</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="literal">-Dmaven</span>.wagon.http.ssl.insecure=true install</span><br></pre></td></tr></table></figure></li><li><p><strong>jar包导入成功！！！！！！</strong></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之前学习springboot入门的时候就遇到了这样的问题，当时在我室友帮忙下暂时解决了，可之后又冒了出来，后面我尝试的方法有：修改阿里云镜像，更换maven版本等等，都没用，搞的我差点就去学gradle了。这样的一个历史性难题，今天终于站起来解决了，爽！！！</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+GitHub搭建我的博客</title>
      <link href="/2020/01/14/hexo-GitHub/"/>
      <url>/2020/01/14/hexo-GitHub/</url>
      
        <content type="html"><![CDATA[<hr><hr><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). --><p><strong>首次尝试用GitHub+hexo搭建博客，大概步骤记录一下</strong> </p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><h4 id="安装git和node-js"><a href="#安装git和node-js" class="headerlink" title="安装git和node.js"></a>安装git和node.js</h4><ul><li>git：进入<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网下载</a></li><li>node.js：进入<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node.js官网下载</a></li><li>通过以下命令查看是否安装好了git和node.js<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git -<span class="literal">-version</span> </span><br><span class="line">node <span class="literal">-v</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="在自己的磁盘中创建一个文件夹"><a href="#在自己的磁盘中创建一个文件夹" class="headerlink" title="在自己的磁盘中创建一个文件夹"></a>在自己的磁盘中创建一个文件夹</h4><p><img src="/" class="lazyload" data-src="/2020/01/14/hexo-GitHub/path.jpg"  alt="1"></p><p>进入该文件夹后，在路径上输入cmd回车，进入dos窗口输入以下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装hexo</span></span><br><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#安装hexo完成后，再执行下列命令，Hexo将会在指定文件夹中新建所需要的文件</span></span><br><span class="line">hexo init HoboClhBlog</span><br><span class="line">cd HoboClhBlog</span><br><span class="line">npm install</span><br><span class="line"><span class="comment">#输入命令部署在本地的5000端口</span></span><br><span class="line">hexo s <span class="literal">-p</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><strong>此时可以在在本地5000端口访问博客了</strong></p><h3 id="部署在GitHub上"><a href="#部署在GitHub上" class="headerlink" title="部署在GitHub上"></a><strong>部署在GitHub上</strong></h3><h4 id="在GitHub中新建仓库"><a href="#在GitHub中新建仓库" class="headerlink" title="在GitHub中新建仓库"></a>在GitHub中新建仓库</h4><p>进入<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>创建仓库，仓库名必须要遵守格式：账户名.github.io</p><h4 id="配置ssh-Key"><a href="#配置ssh-Key" class="headerlink" title="配置ssh Key"></a>配置ssh Key</h4><ul><li>执行以下命令全局配置一下本地账户：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">"github邮箱号"</span></span><br></pre></td></tr></table></figure></li><li>之后在C:\用户\用户名.ssh这个路径下会生成两个文件：id_rsa和id_rsa.pub</li><li>使用记事本打开复制id_rsa.pub，复制</li><li>打开GitHub–&gt;右上角头像–&gt;settings–&gt;SSH and GPG Keys</li><li>点击new SSH Key，将刚刚的内容粘贴</li><li>完毕</li></ul><h4 id="在博客根目录下的-config-yml-文件中修改以下"><a href="#在博客根目录下的-config-yml-文件中修改以下" class="headerlink" title="在博客根目录下的 _config.yml 文件中修改以下"></a>在博客根目录下的 _config.yml 文件中修改以下</h4><p><img src="/" class="lazyload" data-src="/2020/01/14/hexo-GitHub/config-1.png"  alt="config1"><br><img src="/" class="lazyload" data-src="/2020/01/14/hexo-GitHub/config-2.png"  alt="config2"></p><h4 id="安装部署插件、上传"><a href="#安装部署插件、上传" class="headerlink" title="安装部署插件、上传"></a>安装部署插件、上传</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer</span><span class="literal">-git</span> -<span class="literal">-save</span> <span class="comment">#安装插件</span></span><br><span class="line">hexo g <span class="comment">#生成静态文件</span></span><br><span class="line">hexo d <span class="comment">#上传至GitHub</span></span><br></pre></td></tr></table></figure><h4 id="完成使用-GitHub用户名-github-io即可进入博客"><a href="#完成使用-GitHub用户名-github-io即可进入博客" class="headerlink" title="完成使用 GitHub用户名.github.io即可进入博客"></a>完成使用 GitHub用户名.github.io即可进入博客</h4><h3 id="修改博客主题"><a href="#修改博客主题" class="headerlink" title="修改博客主题"></a><strong>修改博客主题</strong></h3><h4 id="先挑选一款"><a href="#先挑选一款" class="headerlink" title="先挑选一款"></a>先挑选一款</h4><p>进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a>挑选一款自己喜欢的，在GitHub上下载</p><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><ul><li>将下载的主题放在博客根目录下的themes文件夹中，</li><li>修改博客根目录下配置文件,修改成刚刚下载的主题名<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-meadow</span></span><br></pre></td></tr></table></figure><h4 id="重新部署至GitHub"><a href="#重新部署至GitHub" class="headerlink" title="重新部署至GitHub"></a>重新部署至GitHub</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="literal">-p</span> <span class="number">5555</span> <span class="comment">#本地先预览</span></span><br><span class="line">hexo g  </span><br><span class="line">hexo d  <span class="comment">#上传</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
