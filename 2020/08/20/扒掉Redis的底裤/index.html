<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>扒掉Redis的底裤 | Hobo's blog</title><meta name="description" content="扒掉Redis的底裤"><meta name="keywords" content="Redis,面试题"><meta name="author" content="Hobo"><meta name="copyright" content="Hobo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/blogger.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="扒掉Redis的底裤"><meta name="twitter:description" content="扒掉Redis的底裤"><meta name="twitter:image" content="https://hobo-clh.github.io/img/cover/redis2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="扒掉Redis的底裤"><meta property="og:url" content="https://hobo-clh.github.io/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/"><meta property="og:site_name" content="Hobo's blog"><meta property="og:description" content="扒掉Redis的底裤"><meta property="og:image" content="https://hobo-clh.github.io/img/cover/redis2.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://hobo-clh.github.io/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/"><link rel="prev" title="Boot自动装配原理以及自定义starter`" href="https://hobo-clh.github.io/2020/09/03/Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89starter/"><link rel="next" title="synchronized必知必会" href="https://hobo-clh.github.io/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://hobo-clh.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"本人,超帥,吊啊,Hobo","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/hobo.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对Redis-的理解"><span class="toc-number">1.1.</span> <span class="toc-text">谈谈你对Redis 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的优缺点"><span class="toc-number">1.2.</span> <span class="toc-text">Redis的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis有多少种数据类型"><span class="toc-number">2.1.</span> <span class="toc-text">Redis有多少种数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis持久化"><span class="toc-number">3.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Redis持久化"><span class="toc-number">3.1.</span> <span class="toc-text">什么是Redis持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的持久化机制"><span class="toc-number">3.2.</span> <span class="toc-text">Redis的持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB"><span class="toc-number">3.2.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF"><span class="toc-number">3.2.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何选择合适的持久化方式"><span class="toc-number">3.3.</span> <span class="toc-text">如何选择合适的持久化方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis内存相关"><span class="toc-number">4.</span> <span class="toc-text">Redis内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#expire设置key-的过期时间，如何处理过期的数据"><span class="toc-number">4.1.</span> <span class="toc-text">expire设置key 的过期时间，如何处理过期的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的过期键的删除策略"><span class="toc-number">4.2.</span> <span class="toc-text">Redis的过期键的删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#①、定时删除"><span class="toc-number">4.2.1.</span> <span class="toc-text">①、定时删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#②、惰性删除"><span class="toc-number">4.2.2.</span> <span class="toc-text">②、惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#③、定期删除"><span class="toc-number">4.2.3.</span> <span class="toc-text">③、定期删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的内存淘汰策略"><span class="toc-number">4.3.</span> <span class="toc-text">Redis的内存淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的内存用完了怎么办"><span class="toc-number">4.4.</span> <span class="toc-text">Redis的内存用完了怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis如何做内存优化"><span class="toc-number">4.5.</span> <span class="toc-text">Redis如何做内存优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务"><span class="toc-number">5.1.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID概述"><span class="toc-number">5.2.</span> <span class="toc-text">ACID概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务的三个阶段"><span class="toc-number">5.3.</span> <span class="toc-text">Redis事务的三个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务相关命令"><span class="toc-number">5.4.</span> <span class="toc-text">Redis事务相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务支持隔离性吗？"><span class="toc-number">5.5.</span> <span class="toc-text">Redis事务支持隔离性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务保证原子性吗，支持回滚吗？"><span class="toc-number">5.6.</span> <span class="toc-text">Redis事务保证原子性吗，支持回滚吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">5.7.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群方案"><span class="toc-number">6.</span> <span class="toc-text">集群方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的主从架构"><span class="toc-number">6.1.</span> <span class="toc-text">Redis的主从架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis主从复制原理"><span class="toc-number">6.2.</span> <span class="toc-text">Redis主从复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哨兵模式"><span class="toc-number">6.3.</span> <span class="toc-text">哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式问题"><span class="toc-number">7.</span> <span class="toc-text">分布式问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis实现互斥锁"><span class="toc-number">7.1.</span> <span class="toc-text">Redis实现互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">7.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存异常"><span class="toc-number">8.</span> <span class="toc-text">缓存异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存雪崩"><span class="toc-number">8.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存穿透"><span class="toc-number">8.2.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是布隆过滤器"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存击穿"><span class="toc-number">8.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存预热"><span class="toc-number">8.4.</span> <span class="toc-text">缓存预热</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis和Memcache的区别"><span class="toc-number">9.1.</span> <span class="toc-text">Redis和Memcache的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis异步队列如何实现"><span class="toc-number">9.2.</span> <span class="toc-text">Redis异步队列如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis回收采用的是什么算法"><span class="toc-number">9.3.</span> <span class="toc-text">Redis回收采用的是什么算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis常见性能问题和解决方案？"><span class="toc-number">9.4.</span> <span class="toc-text">Redis常见性能问题和解决方案？</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cover/redis2.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hobo's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">扒掉Redis的底裤</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-20 13:29:12"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-20 13:34:18"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 13 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="谈谈你对Redis-的理解"><a href="#谈谈你对Redis-的理解" class="headerlink" title="谈谈你对Redis 的理解"></a>谈谈你对Redis 的理解</h3><p>redis是一种高性能的NoSQL 键值对存储型数据库，他支持多种数据结构</p>
<p>它是将数据存储在内存中，所以它的效率非常高，读写速度很快</p>
<p>redis还支持事务，我们一般都是将redis作为缓存来使用。</p>
<p>除此之外，redis也经常用来做分布式锁、持久化、多种集群方案</p>
<h3 id="Redis的优缺点"><a href="#Redis的优缺点" class="headerlink" title="Redis的优缺点"></a>Redis的优缺点</h3><p>redis优点：</p>
<ul>
<li><p>redis将数据存储在内存，速度快</p>
</li>
<li><p>相比于memcache，redis还支持数据持久化</p>
</li>
<li><p>支持多种数据结构，有String、List、Set、ZSet、Hash等五大数据结构还有其他的数据结构</p>
</li>
<li><p>支持主从复制，主机会自动将数据同步在从机，进行读写分离</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>因为redis将数据存储在内存中，它会收到物理内存的限制，不太适合海量的高性能数据读写</li>
<li>redis宕机时，不具备自动容错和恢复功能</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Redis有多少种数据类型"><a href="#Redis有多少种数据类型" class="headerlink" title="Redis有多少种数据类型"></a>Redis有多少种数据类型</h3><p>String、List、Set、ZSet、Hash</p>
<p>还有bitmaps、hyperloglogs 、geospatial</p>
<ul>
<li>Redis五种数据类型的应用场景</li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">存储值</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">做简单的键值对缓存、计数器</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">列表</td>
<td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">无序集合</td>
<td align="center">交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td align="center">ZSet</td>
<td align="center">有序集合</td>
<td align="center">去重但可以排序，如获取排名前几名的用户</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">结构化的数据，比如一个对象</td>
</tr>
</tbody></table>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化"></a>什么是Redis持久化</h3><p>持久化就是把内存的数据保存在磁盘中，防止宕机时，数据丢失</p>
<h3 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h3><p>redis提供了两种持久化机制RDB（默认）和AOF</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB是将支持当前数据的快照存成一个数据文件的持久化机制</p>
<p>优点</p>
<ul>
<li>只有一个文件dump.rdb，容灾行好，一个文件可以保存0到安全的磁盘</li>
<li>性能最大化，他会fork一个子进程来完成数据库的持久化，主进程继续处理命令，保证的redis 的高性能</li>
<li>恢复速度更快</li>
</ul>
<p>缺点</p>
<ul>
<li><p>数据安全性较低。因为是间隔一段时间进行持久化，如果在持久化期间发生事故，会丢失数据</p>
<p>（适合对数据安全要求不是很苛刻的情况下）</p>
</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>aof默认不开启，需要自己配置</p>
<p>优点</p>
<ul>
<li>数据安全，每进行一次命令就会将其操作记录到aof文件中</li>
</ul>
<p>缺点</p>
<ul>
<li>因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢</li>
</ul>
<h3 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h3><ol>
<li>如果想要最安全的方式，两种都开启</li>
<li>如果数据安全性的问题不是很重要可以开启默认的RDB</li>
</ol>
<h2 id="Redis内存相关"><a href="#Redis内存相关" class="headerlink" title="Redis内存相关"></a>Redis内存相关</h2><h3 id="expire设置key-的过期时间，如何处理过期的数据"><a href="#expire设置key-的过期时间，如何处理过期的数据" class="headerlink" title="expire设置key 的过期时间，如何处理过期的数据"></a>expire设置key 的过期时间，如何处理过期的数据</h3><ol>
<li>定时删除，定时去清理过期的缓存 ttl</li>
<li>惰性删除，当请求过来时，再判断这个key是否已经过期，是则去底层数据库获取数据</li>
<li>定期删除，每隔一段时间就去检查内存中是否存在过期的key，将其删除</li>
</ol>
<h3 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h3><h4 id="①、定时删除"><a href="#①、定时删除" class="headerlink" title="①、定时删除"></a>①、定时删除</h4><p>　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p>
<p>　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。</p>
<p>　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p>
<h4 id="②、惰性删除"><a href="#②、惰性删除" class="headerlink" title="②、惰性删除"></a>②、惰性删除</h4><p>　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p>
<p>　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>
<p>　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</p>
<h4 id="③、定期删除"><a href="#③、定期删除" class="headerlink" title="③、定期删除"></a>③、定期删除</h4><p>　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p>
<p>　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>
<p>　　缺点：难以确定删除操作执行的时长和频率。</p>
<p>　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。</p>
<p>　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</p>
<p>　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p>
<h3 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h3><p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru（least ）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是<strong>最常用</strong>的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p><strong>总结</strong></p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis的内存用完了怎么办"><a href="#Redis的内存用完了怎么办" class="headerlink" title="Redis的内存用完了怎么办"></a>Redis的内存用完了怎么办</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h3><p>好好利用基本数据类型，通常情况下可以将小的key-value使用更加紧凑的方式方一起，比如多个key-value优化成一个key-value</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务就是一组不可分割的操作集合。当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，防止彼此的操作互相干扰</p>
<h3 id="ACID概述"><a href="#ACID概述" class="headerlink" title="ACID概述"></a>ACID概述</h3><ul>
<li><p>原子性(Atomicity )：</p>
<p>值事务是一个不可分割的工作单位，事务中的操作要么全成功，要么全失败</p>
</li>
<li><p>一致性(Consistency)：</p>
<p>这个一致性依赖于开发者，以下为转账的例子</p>
<blockquote>
<p>read(A);   //开启事务</p>
<p>A = A – 100;</p>
<p>write(A);</p>
<p>read(B);</p>
<p>B = B + 50; //</p>
<p>write(B);  //结束事务</p>
<p>//没有体现出事务的一致性</p>
</blockquote>
</li>
<li><p>隔离性(Isolation)：</p>
<p>多个事务并发执行时，事物之间不会相互影响</p>
</li>
<li><p>持久性(Durability）:</p>
<p>事务一旦被提交，它对数据库中数据的改变就是永久的，不会因为数据库服务停止而丢失</p>
</li>
</ul>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><blockquote>
<p>事务开始：multi</p>
<p>命令入队</p>
<p>执行事务：exec</p>
</blockquote>
<h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li><p><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</p>
</li>
<li><p><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</p>
</li>
<li><p><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行出错 正确的命令将会继续执行，如果是命令错误则事务失败</span></span><br><span class="line">localhost:1&gt;multi</span><br><span class="line"><span class="string">"OK"</span></span><br><span class="line">localhost:1&gt;<span class="built_in">set</span> k1 1</span><br><span class="line"><span class="string">"QUEUED"</span></span><br><span class="line">localhost:1&gt;incr k1</span><br><span class="line"><span class="string">"QUEUED"</span></span><br><span class="line">localhost:1&gt;<span class="built_in">set</span> k2 QWE</span><br><span class="line"><span class="string">"QUEUED"</span></span><br><span class="line">localhost:1&gt;incr k2</span><br><span class="line"><span class="string">"QUEUED"</span></span><br><span class="line">localhost:1&gt;get k1</span><br><span class="line"><span class="string">"QUEUED"</span></span><br><span class="line">localhost:1&gt;<span class="built_in">exec</span></span><br><span class="line"> 1)  <span class="string">"OK"</span></span><br><span class="line"> 2)  <span class="string">"2"</span></span><br><span class="line"> 3)  <span class="string">"OK"</span></span><br><span class="line"> 4)  <span class="string">"ERR value is not an integer or out of range"</span></span><br><span class="line"> 5)  <span class="string">"2"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li>WATCH 命令是一个乐观锁（在multi之前执行），可以为 Redis 事务提供 CAS行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>DISCARD：放弃事务，并且客户端会从事务状态中退出。</li>
</ul>
<h3 id="Redis事务支持隔离性吗？"><a href="#Redis事务支持隔离性吗？" class="headerlink" title="Redis事务支持隔离性吗？"></a>Redis事务支持隔离性吗？</h3><p>Redis是单线程程序，它保证在执行事务的时候，不会将事务其中断，事务运行直到执行完事务队列中所有命令为止</p>
<p>因此Redis的事务总是带有隔离性</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗？"><a href="#Redis事务保证原子性吗，支持回滚吗？" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗？"></a>Redis事务保证原子性吗，支持回滚吗？</h3><p>因为Redis是单线程的程序，他的单条命令是原子性的，但是他的事务不支持原子性，如果有一条命令执行失败（不是语法错误），剩下的命令还是会继续完成，所以<strong>不保证原子性，也不支持回滚</strong></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="Redis的主从架构"><a href="#Redis的主从架构" class="headerlink" title="Redis的主从架构"></a>Redis的主从架构</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h3 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h3><p>主从复制的几种模式：</p>
<ul>
<li>一主一从：最简单的主从模型，主机将数据同步给从机，从机提供查询，另外从机可以开启aof，既能保证效率，又可靠。</li>
<li>一主多从：一个主机，多个从机，主机提供数据写入，从机提供数据查询</li>
<li>主从从结构（树形扩展）：一主多从的架构会导致master的数据同步压力过大，所以可以采用树形拓扑的方式，主机只需要同步给其中一台slave，由这台salve再同步给其它的从机。</li>
</ul>
<p>集群之间异步复制</p>
<p><strong>redis 主从复制的核心原理</strong></p>
<p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="/" class="lazyload" data-src="/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/D:%5C%E5%9B%BE%E7%89%87%5Credis.png"  alt="img"></p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/" class="lazyload" data-src="/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/D:%5C%E5%9B%BE%E7%89%87%5Credis2.png"  alt="img"></p>
<ul>
<li>集群监控：监控master和salve是否正常工作</li>
<li>消息通知：当一个哨兵发现master挂掉了，就会通知其他哨兵和其他redis服务，其他哨兵也会也检测master是否真的挂了</li>
<li>故障转移：如果半数以上的哨兵都觉得他挂了，他就真挂了，如何会选出一个哨兵当作代表，去salve中选择一个新的master</li>
<li>配置中心：如果故障转移发生了，会给客户端提高一个新master地址</li>
</ul>
<p>注意：</p>
<ul>
<li>哨兵模式需要多个实例来保证自己的健壮性</li>
<li>哨兵 + redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现互斥锁"><a href="#Redis实现互斥锁" class="headerlink" title="Redis实现互斥锁"></a>Redis实现互斥锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">   String value = redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>指大面积的缓存失效（缓存过期），后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉</p>
<p>解决方案–对症下药</p>
<ol>
<li><p>如果是因为缓存过期导致的，可以在设置缓存过期时间的时候再加上一个随机数</p>
</li>
<li><p>如果是因为redis服务器挂掉，而导致请求全部走的数据库</p>
<ul>
<li>事发前：可以实现Redis的高可用方案①主从架构+哨兵模式②使用Redis Cluster模式，来尽量避免这种情况的发生</li>
<li>事发后：万一Redis真的挂了，就使用设置本地缓存(ehcache)+限流+降级(hystrix)</li>
</ul>
</li>
<li><p>并发量不是很大的情况下可以使用互斥锁（setnx），用来重建缓存</p>
<blockquote>
<p>第一个用户发起请求</p>
<p>查找缓存，缓存中没有</p>
<p>setnx设置，设置一个缓存标记（设置其过期时间，不然可能会造成资源锁死）</p>
<ul>
<li>然后第一个线程会从数据库中获取资源，获取成功后则更新缓存</li>
<li>其他的线程发现这个缓存标记后就进入等待（50ms的样子），然后再从缓存中查询一次</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>指请求查询了缓存和数据库中都没有的数据，导致所有的请求都落在了数据库上，数据库因为短时间内承受大量请求而崩掉</p>
<p>解决方案</p>
<ol>
<li><p>如果缓存中取不到，数据库中也不存在的话，就将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p>
</li>
<li><p>使用布隆过滤器来过滤请求</p>
<blockquote>
<h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h4><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
</blockquote>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>指请求查询缓存中没有而数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永不过期</li>
<li>使用setnx命令设置互斥锁，用来将重建缓存</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><ol>
<li>数据量不大的情况下，可以在项目启动的时候自动将数据加载至缓存</li>
<li>定时刷新页面</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Redis和Memcache的区别"><a href="#Redis和Memcache的区别" class="headerlink" title="Redis和Memcache的区别"></a>Redis和Memcache的区别</h3><table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center"><strong>Redis</strong></th>
<th align="center"><strong>Memcache</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据存储类型</td>
<td align="center">支持多种数据结构，String、List、Set、ZSet、Hash等</td>
<td align="center">支持的数据结构单一</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">支持事务</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">持久化</td>
<td align="center">支持持久化，有RDB（默认）和AOF两种策略可选</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">集群</td>
<td align="center">支持集群，有哨兵模式</td>
<td align="center">没有原生的集群模式</td>
</tr>
<tr>
<td align="center">网络IO模型</td>
<td align="center">多路IO复用模型</td>
<td align="center">多线程，非阻塞IO模式</td>
</tr>
</tbody></table>
<h3 id="Redis异步队列如何实现"><a href="#Redis异步队列如何实现" class="headerlink" title="Redis异步队列如何实现"></a>Redis异步队列如何实现</h3><p>使用List数据结构，rpush生产消息，lpop消费消息（或者lpush、rpop）</p>
<h3 id="Redis回收采用的是什么算法"><a href="#Redis回收采用的是什么算法" class="headerlink" title="Redis回收采用的是什么算法"></a>Redis回收采用的是什么算法</h3><p>LRU（least recently used） 最近最少使用算法</p>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>master最好不要做持久化工作（不明确原因）</li>
<li>为了主从复制的速度和连接稳定性，Slave和Master最好在同一个局域网内</li>
<li>尽量避免在压力较大的主库上增加从库</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hobo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hobo-clh.github.io/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/">https://hobo-clh.github.io/2020/08/20/%E6%89%92%E6%8E%89Redis%E7%9A%84%E5%BA%95%E8%A3%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hobo-clh.github.io" target="_blank">Hobo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/03/Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89starter/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Boot自动装配原理以及自定义starter`</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/12/synchronized%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">synchronized必知必会</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/22/Redis主从模式-哨兵配置/" title="Redis主从模式+哨兵配置"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-22</div><div class="relatedPosts_title">Redis主从模式+哨兵配置</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/22/Linux下安装Redis/" title="Linux下安装Redis"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-22</div><div class="relatedPosts_title">Linux下安装Redis</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'L7w59tzz1mg3lzAlMa1X8YaJ-gzGzoHsz',
  appKey: 'f5kLvcrydFdK780yPqu10vny',
  placeholder: '燥起来啊~',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Hobo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hobo-clh.github.io//">blog</a>! 湘ICP备<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">-20007724号</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>